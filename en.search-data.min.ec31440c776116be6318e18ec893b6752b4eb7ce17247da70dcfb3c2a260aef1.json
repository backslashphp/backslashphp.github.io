[{"id":0,"href":"/backslash/getting-started/introduction/","title":"Introduction","section":"Getting Started","content":"Introduction# Backslash is a modern and opinionated PHP library for building event-sourced applications with CQRS. It is fully compliant with the Dynamic Consistency Boundary specification.\nUnlike most event sourcing libraries built around aggregates with rigid boundaries, Backslash allows you to define consistency boundaries on the fly based on the decision you\u0026rsquo;re making, not based on predetermined aggregate structures.\nImportant note: Backslash has evolved in production for many years at the FNQLHSSC; however, it was originally designed for the company\u0026rsquo;s specific use cases. Nevertheless, Backslash adopts a generic approach to event sourcing and does not distort its fundamental principles.\nCore capabilities# Dynamic consistency boundaries. Define which events matter for each decision. No fixed aggregates; just queries that fetch exactly what you need.\nBuilt-in persistence. PDO-compatible adapters for storing events and projections are included. Supports MySQL and SQLite out of the box.\nSynchronous projections. Projections are updated immediately within the same transaction as command execution, ensuring read-your-writes consistency.\nFramework agnostic. Works with any PHP framework or runs standalone. Use it with Laravel, Symfony, Slim, or your own custom setup.\nEvent replay and projection rebuilding. Reconstruct projections from scratch by replaying historical events, enabling schema changes and bug fixes.\nOptimistic concurrency control. Prevent race conditions with built-in version checking that detects concurrent modifications.\nExtensible through middleware. Add logging, validation, transactions, or any cross-cutting concern by wrapping core operations with middleware.\nStream enrichment. Enhance events with contextual metadata like correlation IDs, user information, or tenant context as they flow through the system.\nBDD-style testing. Write expressive tests using the Scenario component with given-when-then syntax that reads like specifications.\nPrerequisites# While not strictly required, familiarity with event sourcing and CQRS fundamentals is strongly recommended. If these concepts are new to you, start with these resources:\nMartin Fowler on Event Sourcing Event Store – What Is Event Sourcing? Greg Young\u0026rsquo;s Original CQRS Introduction (2007) Microsoft Docs: CQRS Pattern Installing Backslash# Install Backslash using Composer:\n1 composer require backslashphp/backslash Exploring the demo application# The examples in this documentation come from the demo application, a simple course enrollment system where students can subscribe to courses with capacity limits. The demo demonstrates how to define events, build decision-making models, react with event handlers, and maintain projections.\nThe domain chosen for the demo application is inspired by Sara Pellegrini\u0026rsquo;s blog series \u0026ldquo;Kill Aggregate\u0026rdquo;.\nThe demo is intentionally simple to keep focus on Backslash concepts rather than domain complexity. Real applications will have more sophisticated domain logic, but the patterns remain the same.\nDeveloping a Backslash system# Building an event-sourced application with Backslash involves several key steps:\nDefine events that represent facts about what happened in your system Build models that replay events to understand current state and make decisions Write queries to select which events are relevant for each decision Create command handlers that load models, execute business logic, and persist changes Set up event handlers that react to events by updating projections or triggering side effects Backslash handles command routing, event persistence, concurrency control, and event publishing; you focus on expressing your domain logic clearly.\n"},{"id":1,"href":"/backslash/getting-started/architecture-overview/","title":"Architecture Overview","section":"Getting Started","content":"Architecture Overview# Backslash is designed around the core principles of event sourcing and CQRS. Its modular, lightweight, and framework-agnostic architecture allows for gradual adoption or integration into existing systems.\nCore components are provided by Backslash and handle the infrastructure behind event sourcing and CQRS.\nApplication components are written by the developer to implement use cases and domain behavior.\nComponent Core Application Role Events ✓ Represent facts that have occurred within the system. Models ✓ Replay events to hold current state and make decisions that record new events. Queries ✓ Define how to retrieve past events relevant to a model. Repository ✓ Persists model changes to the EventStore and publishes new events on the EventBus. EventNameResolver ✓ Converts event FQCNs to short names and vice versa. EventStore ✓ Stores events as an append-only, queryable log. EventBus ✓ Delivers published events to event handlers. Event handlers ✓ Respond to events to update projections or trigger side effects. Projections ✓ Read-optimized views of the system\u0026rsquo;s current state. ProjectionStore ✓ Persists and retrieves projections. Commands ✓ Express an intention or request to perform an operation on the system. Command handlers ✓ Contain the logic to process commands and update the system accordingly. Dispatcher ✓ Routes commands to their respective handlers. Scenario ✓ Provides helpers for writing BDD-style tests using PHPUnit. Testing scenarios ✓ Define given/when/then test flows using the Scenario test helpers. PdoProxy ✓ Delays the creation of a PDO connection until it\u0026rsquo;s needed. Storage adapters ✓ Provide PDO-based persistence for EventStore and ProjectionStore. Serializer ✓ Handles the serialization and deserialization of events and projections. Middlewares ✓ ✓ Add custom logic around core components operations. Stream enrichers ✓ Modify or enhance events going through EventStore and EventBus. Understanding how it works# Backslash separates write operations (commands) from read operations (queries) using the CQRS pattern. The write side and read side operate independently, connected only through events.\nWrite side flow# When you execute a command, here\u0026rsquo;s what happens:\nCommand dispatch: The Dispatcher receives a command and routes it to the registered command handler Query building: The handler builds a query to determine which events are needed by the model Event loading: The Repository fetches matching events from the EventStore State reconstruction: Events are replayed into the model to rebuild its current state Business decision: The model executes business logic and records new events Event persistence: The Repository appends new events to the EventStore Event publishing: New events are published to the EventBus Read side flow# When events are published, the read side reacts:\nEvent notification: The EventBus delivers events to subscribed event handlers Projection update: Event handlers load projections from the ProjectionStore State modification: Projections are updated based on event data Projection persistence: Updated projections are stored back to the ProjectionStore This separation ensures that complex business rules don\u0026rsquo;t complicate queries, and query optimization doesn\u0026rsquo;t constrain domain logic.\nExtensibility# Backslash provides two mechanisms for extending functionality:\nMiddlewares wrap core operations (command dispatch, event storage, projection updates) to add cross-cutting concerns like logging, validation, or transactions.\nStream enrichers modify events as they flow through the system, adding metadata such as correlation IDs, user context, or timestamps.\nHandling concurrency# Backslash uses optimistic concurrency control to prevent race conditions when writing events to the EventStore. The PdoEventStoreAdapter enforces this using a conditional append in SQL that checks the expected number of events in a stream before appending new ones. If another process has modified the stream in the meantime, a concurrency exception is thrown, allowing you to retry the operation with the latest state.\nWhat\u0026rsquo;s not included# Backslash focuses exclusively on event sourcing and CQRS infrastructure. It intentionally does not provide:\nHTTP routing or web framework components User interface frameworks or templating Process managers or sagas for long-running workflows Message queue integration (though you can add this via middleware) Authentication or authorization mechanisms Database migration tools These concerns are best handled by your chosen framework or dedicated libraries, allowing Backslash to remain framework-agnostic and focused on its core purpose.\n"},{"id":2,"href":"/backslash/getting-started/quick-start-guide/","title":"Quick Start Guide","section":"Getting Started","content":"Quick Start Guide# This guide walks you through setting up and running the Backslash demo application, helping you understand the basic workflow before building your own application.\nInstalling the demo# Clone the demo repository and install dependencies:\n1 2 3 git clone https://github.com/backslashphp/demo.git cd demo composer install Running the demo# Execute the demo script:\n1 2 cd bin php demo.php The demo will automatically create the SQLite database and execute a series of commands demonstrating:\nDefining a course with capacity limits Registering students Subscribing students to courses Handling capacity constraints Updating projections in real-time Understanding the demo structure# The demo follows a vertical slice architecture (VSA):\nsrc/ ├── Feature/ │ ├── {Feature name}/ │ │ ├── Command/ # Commands and handler │ │ ├── Event/ # Domain events │ │ ├── Exception/ # Business rule violations │ │ ├── Model/ # Decision-making models │ │ └── Test/ # Test scenarios │ └── Shared/ │ └── Projection/ # Shared projections └── Infrastructure/ └── Container.php # Dependency injectionThis structure is a recommended approach that works well for event sourcing applications. However, Backslash does not impose any specific code structure; you\u0026rsquo;re free to organize your application in whatever way suits your needs.\nExploring the code# As you read through this documentation, explore the demo application\u0026rsquo;s source code. Each concept explained in the following sections has a concrete implementation in the demo that you can study and experiment with.\n"},{"id":3,"href":"/backslash/event-sourcing/understanding-event-sourcing/","title":"Understanding Event Sourcing","section":"Event Sourcing","content":"Understanding Event Sourcing# Event sourcing is a pattern where you store the state of your application as a sequence of events rather than just the current state. Instead of updating records in place, you append new events describing what happened.\nEvents as source of truth# In traditional CRUD applications, you store the current state:\nUPDATE students SET name = \u0026#39;Alice Johnson\u0026#39; WHERE id = 123;With event sourcing, you store what happened:\nStudentRegistered(id: 123, name: \u0026#39;Alice Johnson\u0026#39;) StudentNameChanged(id: 123, from: \u0026#39;Alice Johnson\u0026#39;, to: \u0026#39;Alice Cooper\u0026#39;)The current state is derived by replaying these events in order.\nReplaying events to reconstruct state# Systems rebuild state by processing events sequentially:\nstate = EmptyState for each event in events: state = apply(state, event)This replay mechanism enables:\nAudit trail: Complete history of all changes Debugging: Replay events to understand how the system reached its current state Time travel: Query past states by replaying events up to a specific point Benefits of event sourcing# Complete audit trail. Every change is recorded as an immutable event, providing a full history for compliance, debugging, and analysis.\nDebugging and troubleshooting. Replay events to reproduce bugs or understand how the system reached a problematic state.\nFlexible projections. Build multiple read models from the same events, optimized for different queries.\nBusiness insights. Analyze event history to understand user behavior, identify trends, and make data-driven decisions.\n"},{"id":4,"href":"/backslash/event-sourcing/defining-events/","title":"Defining Events","section":"Event Sourcing","content":"Defining Events# Events represent immutable facts about what happened in your system. They are the building blocks of event sourcing and capture domain changes as a permanent record.\nCreating event classes# In Backslash, events are simple classes that implement the EventInterface:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 readonly class StudentRegisteredEvent implements EventInterface { use ToArrayTrait; // Handles automatic serialization public function __construct( public string $studentId, public string $name, ) { } public function getIdentifiers(): Identifiers { return new Identifiers([ \u0026#39;studentId\u0026#39; =\u0026gt; $this-\u0026gt;studentId, ]); } } This is a simple single-entity model. For more complex scenarios, see CourseSubscriptionModel in the demo application, which demonstrates a multi-entity model that loads events from both students and courses to enforce rules that span multiple entities.\nThe readonly keyword is recommended to enforce immutability; once created, the event cannot be modified.\nImplementing the EventInterface# All events must implement Backslash\\Event\\EventInterface:\n1 2 3 4 5 6 interface EventInterface { public function getIdentifiers(): Identifiers; public function toArray(): array; public static function fromArray(array $data): self; } The getIdentifiers() method returns identifiers used to scope the event. The toArray() and fromArray() methods handle serialization for storage and retrieval.\nWorking with identifiers# Backslash events can include identifiers for multiple entities, following the Dynamic Consistency Boundary specification. Identifiers determine which events belong together when enforcing business rules.\nThe StudentSubscribedToCourseEvent includes identifiers for both student and course because the subscription action involves both entities:\n1 2 3 4 5 6 7 public function getIdentifiers(): Identifiers { return new Identifiers([ \u0026#39;studentId\u0026#39; =\u0026gt; $this-\u0026gt;studentId, \u0026#39;courseId\u0026#39; =\u0026gt; $this-\u0026gt;courseId, ]); } This multi-entity identification enables dynamic consistency boundaries. When enforcing the rule \u0026ldquo;a student can only subscribe if the course isn\u0026rsquo;t full\u0026rdquo;, you need events from both the student and the course within the same consistency boundary.\nCompare this with CourseDefinedEvent, which only identifies the course:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 readonly class CourseDefinedEvent implements EventInterface { use ToArrayTrait; public function __construct( public string $courseId, public string $name, public int $capacity, ) { } public function getIdentifiers(): Identifiers { return new Identifiers([ \u0026#39;courseId\u0026#39; =\u0026gt; $this-\u0026gt;courseId, ]); } } Different events need different identifiers depending on which entities participated in the action and which consistency boundaries they support.\nSerializing events# Backslash provides ToArrayTrait that uses reflection to automatically implement toArray() and fromArray(). All properties must be scalar types (string, int, float, bool, or null) or arrays of scalar types. Constructor parameters must match the properties exactly by name and type.\n1 2 3 4 5 $event = new StudentSubscribedToCourseEvent(\u0026#39;123\u0026#39;, \u0026#39;456\u0026#39;); $serialized = $event-\u0026gt;toArray(); // [\u0026#39;studentId\u0026#39; =\u0026gt; \u0026#39;123\u0026#39;, \u0026#39;courseId\u0026#39; =\u0026gt; \u0026#39;456\u0026#39;] $restored = StudentSubscribedToCourseEvent::fromArray($serialized); For events with value objects or complex structures, implement toArray() and fromArray() manually:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 readonly class CourseScheduleChangedEvent implements EventInterface { public function __construct( public string $courseId, public DateTimeImmutable $startDate, public DateTimeImmutable $endDate, ) { } public function getIdentifiers(): Identifiers { return new Identifiers([ \u0026#39;courseId\u0026#39; =\u0026gt; $this-\u0026gt;courseId, ]); } public function toArray(): array { return [ \u0026#39;courseId\u0026#39; =\u0026gt; $this-\u0026gt;courseId, \u0026#39;startDate\u0026#39; =\u0026gt; $this-\u0026gt;startDate-\u0026gt;format(\u0026#39;Y-m-d\u0026#39;), \u0026#39;endDate\u0026#39; =\u0026gt; $this-\u0026gt;endDate-\u0026gt;format(\u0026#39;Y-m-d\u0026#39;), ]; } public static function fromArray(array $data): self { return new self( $data[\u0026#39;courseId\u0026#39;], new DateTimeImmutable($data[\u0026#39;startDate\u0026#39;]), new DateTimeImmutable($data[\u0026#39;endDate\u0026#39;]), ); } } Best practices# Use past tense for event names. Events describe completed actions: StudentRegisteredEvent, not RegisterStudentEvent; CourseCapacityChangedEvent, not ChangeCourseCapacityEvent.\nKeep events immutable. Mark classes as readonly and use public readonly properties, or use private properties with public getters. Never modify an event after creation.\nInclude all relevant identifiers. Add identifiers for every entity that participated in the event, not just a single aggregate root.\nStore facts, not derived data. Events should contain essential information about what happened, not calculations or data derivable from other events.\nKeep events focused. Each event should represent a single fact. Avoid capturing multiple unrelated changes in one event.\nConsider recording both old and new values. For state changes, recording previous and new values provides a complete audit trail.\nMake serialization explicit for complex types. If your event contains value objects or non-scalar types, implement toArray() and fromArray() manually rather than relying on automatic serialization.\n"},{"id":5,"href":"/backslash/event-sourcing/querying-events/","title":"Querying Events","section":"Event Sourcing","content":"Querying Events# Queries define which events should be loaded from the EventStore. They act as dynamic consistency boundaries, allowing you to load exactly the events needed to make a specific decision. The boundaries are determined at runtime based on the operation being performed, not predefined at design time.\nQueries also play a crucial role in optimistic concurrency control. Before appending new events, the query is re-executed to verify that no other process has added events to the stream in the meantime.\nUnderstanding queries# Queries implement QueryInterface and describe which events to fetch based on event class and identifiers.\nHere are some basic query examples:\n1 2 3 4 5 6 7 8 9 // Load all events of a specific type EventClass::is(StudentRegisteredEvent::class) // Load events for a specific entity Identifier::is(\u0026#39;studentId\u0026#39;, \u0026#39;student-123\u0026#39;) // Combine filters EventClass::is(StudentRegisteredEvent::class) -\u0026gt;and(Identifier::is(\u0026#39;studentId\u0026#39;, \u0026#39;student-123\u0026#39;)) The demo includes a static method on each Model to build its query. This is a convenient convention but not required by Backslash; queries can be created anywhere in your application.\nHere\u0026rsquo;s a simple case for CourseCapacityModel:\n1 2 3 4 5 6 7 public static function buildQuery(string $courseId): QueryInterface { return EventClass::in( CourseCapacityChangedEvent::class, CourseDefinedEvent::class, )-\u0026gt;and(Identifier::is(\u0026#39;courseId\u0026#39;, $courseId)); } This query loads events related to a single course\u0026rsquo;s capacity.\nBuilding queries with EventClass and Identifier# Queries combine event class filters with identifier filters:\nEventClass filters:\nEventClass::is(EventClass::class) - Single event type EventClass::in(Event1::class, Event2::class) - Multiple event types Identifier filters:\nIdentifier::is('key', 'value') - Exact identifier match Multiple identifiers can be combined Combining filters:\n-\u0026gt;and() - Both conditions must match -\u0026gt;or() - Either condition must match Building multi-entity queries# The CourseSubscriptionModel demonstrates a more complex query spanning multiple entities:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static function buildQuery(string $studentId, string $courseId): QueryInterface { $eventForThisCourseLifecycle = EventClass::in( CourseCapacityChangedEvent::class, CourseDefinedEvent::class, )-\u0026gt;and(Identifier::is(\u0026#39;courseId\u0026#39;, $courseId)); $eventsForThisStudentLifecycle = EventClass::is( StudentRegisteredEvent::class, )-\u0026gt;and(Identifier::is(\u0026#39;studentId\u0026#39;, $studentId)); $eventsForThisStudentSubscriptions = EventClass::in( StudentUnsubscribedFromCourseEvent::class, StudentSubscribedToCourseEvent::class, )-\u0026gt;and(Identifier::is(\u0026#39;studentId\u0026#39;, $studentId)); $eventsForSubscriptionsToThisCourse = EventClass::in( StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, )-\u0026gt;and(Identifier::is(\u0026#39;courseId\u0026#39;, $courseId)); return $eventForThisCourseLifecycle -\u0026gt;or($eventsForThisStudentLifecycle) -\u0026gt;or($eventsForThisStudentSubscriptions) -\u0026gt;or($eventsForSubscriptionsToThisCourse); } This query loads:\nThe course\u0026rsquo;s lifecycle events (definition and capacity changes) The student\u0026rsquo;s registration All of this student\u0026rsquo;s subscription events All subscription events for this course (to count enrollments) This multi-entity boundary enables the Model to enforce rules like \u0026ldquo;a student can only subscribe if the course isn\u0026rsquo;t full\u0026rdquo; and \u0026ldquo;a student can subscribe to at most 3 courses\u0026rdquo;.\nBest practices# Build queries per decision. Each business decision should define its own query that loads exactly the events needed.\nStart narrow, expand as needed. Begin with the minimal set of events and expand the query only when business rules require additional context.\nDocument complex queries. Multi-entity queries can be intricate; add comments explaining what events are loaded and why.\nUse static factory methods. Place query building logic in static methods on your models for discoverability.\nKeep queries focused. Don\u0026rsquo;t load events that aren\u0026rsquo;t needed for the decision being made.\n"},{"id":6,"href":"/backslash/event-sourcing/building-models/","title":"Building Models","section":"Event Sourcing","content":"Building Models# Models are decision-making components that encapsulate domain logic. They are rebuilt from events and record new events when business rules are satisfied.\nIntroducing the Repository# Before diving into models, it\u0026rsquo;s important to understand the Repository. The Repository is a core Backslash component responsible for:\nLoading events based on a query Replaying those events into a model Persisting new events recorded by the model Publishing events to the EventBus You\u0026rsquo;ll use the Repository in command handlers like this:\n1 2 3 4 5 6 7 8 // Load a model using a query $model = $repository-\u0026gt;loadModel(ModelClass::class, $query); // Execute business logic $model-\u0026gt;makeDecision(); // Persist changes $repository-\u0026gt;storeChanges($model); Creating model classes# Models extend AbstractModel, which implements ModelInterface:\n1 2 3 4 5 6 interface ModelInterface { public function getChanges(): RecordedEventStream; public function clearChanges(): void; public function applyEvents(RecordedEventStream $stream): void; } These methods allow the Repository to:\nLoad events into the model with applyEvents() Retrieve new events recorded by the model with getChanges() Clear recorded events after persistence with clearChanges() Here\u0026rsquo;s an example of a model extending AbstractModel:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 use Backslash\\Model\\AbstractModel; class CourseCapacityModel extends AbstractModel { private ?string $courseId = null; private int $capacity = 0; private bool $defined = false; public function change(int $newCapacity): void { if (!$this-\u0026gt;defined) { throw new CourseNotDefinedException(); } if ($newCapacity === $this-\u0026gt;capacity) { return; // Idempotent } $this-\u0026gt;record(new CourseCapacityChangedEvent( courseId: $this-\u0026gt;courseId, old: $this-\u0026gt;capacity, new: $newCapacity )); } protected function applyCourseDefinedEvent(CourseDefinedEvent $event): void { $this-\u0026gt;courseId = $event-\u0026gt;courseId; $this-\u0026gt;capacity = $event-\u0026gt;capacity; $this-\u0026gt;defined = true; } protected function applyCourseCapacityChangedEvent( CourseCapacityChangedEvent $event ): void { $this-\u0026gt;capacity = $event-\u0026gt;new; } } Replaying events with apply methods# Apply methods rebuild the model\u0026rsquo;s state from events. They follow the naming pattern apply{EventClassName}:\n1 2 3 4 5 protected function applyCourseCapacityChangedEvent( CourseCapacityChangedEvent $event ): void { $this-\u0026gt;capacity = $event-\u0026gt;new; } Apply methods are invoked automatically during event replay. They update internal state based on event data without performing validation or business logic. Think of them as pure state transitions.\nCreating decision methods# Public methods enforce business rules. They inspect internal state, validate input, check for idempotency, and record new events using $this-\u0026gt;record() when rules are satisfied:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public function change(int $newCapacity): void { // Validate preconditions if (!$this-\u0026gt;defined) { throw new CourseNotDefinedException(); } // Check idempotency if ($newCapacity === $this-\u0026gt;capacity) { return; } // Record the decision $this-\u0026gt;record(new CourseCapacityChangedEvent( courseId: $this-\u0026gt;courseId, old: $this-\u0026gt;capacity, new: $newCapacity )); } Decision methods express business logic clearly. They throw domain exceptions when rules are violated and record events when decisions are valid.\nRecording new events# Use $this-\u0026gt;record() to append new events:\n1 2 3 4 $this-\u0026gt;record(new StudentRegisteredEvent( studentId: $studentId, name: $name )); The record() method does two things:\nAutomatically calls the corresponding apply method, updating the model\u0026rsquo;s state immediately Adds the event to the model\u0026rsquo;s internal list of changes This means recorded events are:\nApplied immediately to the model via apply methods Returned by getChanges() for persistence Not yet persisted until Repository::storeChanges() is called Note that you use $this-\u0026gt;record() rather than returning events because AbstractModel manages the internal event stream. This design allows models to record multiple events for complex operations while maintaining clean method signatures.\nBest practices# Keep models focused. Each model should enforce a specific set of business rules. Don\u0026rsquo;t create god models that try to enforce everything.\nUse domain exceptions. When business rules are violated, throw descriptive exceptions that explain what went wrong.\nCheck idempotency. Before recording events, verify the operation isn\u0026rsquo;t redundant.\nApply methods are pure state transitions. Never perform validation or business logic in apply methods; they only update state.\nDecision methods contain business logic. All validation, rule enforcement, and conditional logic belongs in public decision methods.\nRecord events, don\u0026rsquo;t return them. Use $this-\u0026gt;record() to append events; don\u0026rsquo;t return events from decision methods.\nModels are stateful during their lifetime. A model instance retains its state throughout the request. Load it once, make decisions, then store changes.\nOne model instance per decision. Don\u0026rsquo;t reuse a model instance for multiple unrelated decisions. Load a fresh model for each command.\n"},{"id":7,"href":"/backslash/cqrs/understanding-cqrs/","title":"Understanding CQRS","section":"Commands and Projections (CQRS)","content":"Understanding CQRS# Command Query Responsibility Segregation (CQRS) is a pattern that separates read and write operations into distinct models. Instead of using the same model for both updates and queries, CQRS uses different models optimized for their specific purposes.\nSeparating write and read sides# Write side (Commands):\nProcesses commands that express intent to change state Uses models that enforce business rules Records events when operations succeed Read side (Queries):\nProvides optimized views of current state Uses projections denormalized for specific queries Updated by reacting to events from the write side In Backslash:\nCommands → Handlers → Models → Events Events → Event Handlers → Projections Benefits of CQRS# Independent optimization. Write and read models can be optimized separately; complex business rules don\u0026rsquo;t complicate queries, and query optimization doesn\u0026rsquo;t constrain domain logic.\nDenormalized views. Projections can be structured however queries need them, with precomputed values and joined data for fast reads.\nClear separation of concerns. Business logic lives in models; query logic lives in projections. Each has a single, focused responsibility.\n"},{"id":8,"href":"/backslash/cqrs/dispatching-commands/","title":"Dispatching Commands","section":"Commands and Projections (CQRS)","content":"Dispatching Commands# Commands represent intentions to change the system\u0026rsquo;s state. Unlike events that describe what happened, commands express what should happen. They carry the information needed to make a business decision and are the entry points for all write operations.\nCommands are dispatched through a Dispatcher that routes them to their corresponding handlers. Command handlers coordinate whatever operations are necessary to fulfill the command\u0026rsquo;s intent.\nDefining commands# Commands are simple data transfer objects with no behavior. They don\u0026rsquo;t need to implement any interface; they\u0026rsquo;re just plain PHP classes that carry data:\n1 2 3 4 5 6 7 8 readonly class RegisterStudentCommand { public function __construct( public string $studentId, public string $name, ) { } } Mark commands as readonly to emphasize their immutability. Commands should never change once created.\nNaming commands# Command names should clearly express intent using imperative verbs:\n1 2 3 4 5 6 7 8 9 10 // Good: clear intent RegisterStudentCommand ChangeCourseCapacityCommand SubscribeStudentToCourseCommand UnsubscribeStudentFromCourseCommand // Avoid: unclear or passive names StudentCommand CourseCapacityCommand StudentCourseCommand Creating command handlers# Command handlers implement HandlerInterface:\n1 2 3 4 interface HandlerInterface { public function handle(object $command): void; } Use HandleCommandTrait to automatically route commands to methods based on class names:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use Backslash\\CommandDispatcher\\HandlerInterface; use Backslash\\CommandDispatcher\\HandleCommandTrait; class StudentCommandHandler implements HandlerInterface { use HandleCommandTrait; public function __construct( private RepositoryInterface $repository, ) { } protected function handleRegisterStudentCommand( RegisterStudentCommand $command, ): void { $query = StudentRegistrationModel::buildQuery($command-\u0026gt;studentId); $model = $this-\u0026gt;repository-\u0026gt;loadModel( StudentRegistrationModel::class, $query ); $model-\u0026gt;register($command-\u0026gt;studentId, $command-\u0026gt;name); $this-\u0026gt;repository-\u0026gt;storeChanges($model); } } The trait looks for methods named by prefixing handle to the command\u0026rsquo;s short class name.\nThe command handler workflow# A common pattern for command handlers working with models follows these steps:\nBuild the query to load relevant events Load the model from the Repository Execute business logic by calling decision methods Persist changes back to the Repository 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 protected function handleChangeCourseCapacityCommand( ChangeCourseCapacityCommand $command, ): void { // 1. Build query $query = CourseCapacityModel::buildQuery($command-\u0026gt;courseId); // 2. Load model $model = $this-\u0026gt;repository-\u0026gt;loadModel( CourseCapacityModel::class, $query ); // 3. Execute business logic $model-\u0026gt;change($command-\u0026gt;capacity); // 4. Persist changes $this-\u0026gt;repository-\u0026gt;storeChanges($model); } The Repository handles event replay, concurrency checks, event persistence, and event publishing. Command handlers coordinate operations.\nHowever, command handlers are not limited to working with models. They can perform any operation needed to fulfill the command\u0026rsquo;s intent. For example, a handler might call external services, send notifications, or perform system operations:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class SystemCommandHandler implements HandlerInterface { use HandleCommandTrait; public function __construct( private MailerInterface $mailer, private LoggerInterface $logger, ) { } protected function handleSendWelcomeEmailCommand( SendWelcomeEmailCommand $command, ): void { $this-\u0026gt;mailer-\u0026gt;send( to: $command-\u0026gt;email, subject: \u0026#39;Welcome!\u0026#39;, body: $this-\u0026gt;buildWelcomeMessage($command-\u0026gt;name) ); $this-\u0026gt;logger-\u0026gt;info(\u0026#39;Welcome email sent\u0026#39;, [ \u0026#39;email\u0026#39; =\u0026gt; $command-\u0026gt;email, ]); } private function buildWelcomeMessage(string $name): string { return \u0026#34;Hello {$name}, welcome to our platform!\u0026#34;; } } The key is that handlers encapsulate the logic needed to execute a command, whether that involves models, external services, or any other operations.\nRegistering handlers# Register command handlers with the Dispatcher during application bootstrap:\n1 2 3 4 $dispatcher-\u0026gt;registerHandler( RegisterStudentCommand::class, new HandlerProxy(fn() =\u0026gt; $container-\u0026gt;get(StudentCommandHandler::class)) ); Adding middleware# Middleware wraps command dispatch to add cross-cutting concerns like logging, validation, or transactions:\n1 2 3 4 5 6 $dispatcher = new Dispatcher(); // Add transaction management $dispatcher-\u0026gt;addMiddleware( new ProjectionStoreTransactionCommandDispatcherMiddleware($projectionStore) ); Middleware executes in LIFO order. The last registered middleware wraps all previous ones.\nBest practices# Keep commands simple. Commands should be data containers with no logic. All validation and business rules belong in models.\nUse descriptive command names. Command names should clearly express intent using action verbs.\nGroup related commands. Commands that share dependencies or operate on related concepts can share a handler.\nHandle each command once. Each command class should map to exactly one handler method.\nLet exceptions propagate. Domain exceptions should propagate to the dispatcher where middleware can handle them consistently.\nKeep handlers focused. Command handlers should coordinate operations, not implement business logic. Business rules belong in models.\nMake commands serializable. Commands should only contain scalar types and arrays so they can be serialized for queuing or logging.\n"},{"id":9,"href":"/backslash/cqrs/reacting-with-event-handlers/","title":"Reacting with Event Handlers","section":"Commands and Projections (CQRS)","content":"Reacting with Event Handlers# Event handlers respond to events by updating projections, triggering side effects, or integrating with external systems. They subscribe to specific event types and execute synchronously when those events are published.\nCreating event handlers# Event handlers implement EventHandlerInterface:\n1 2 3 4 interface EventHandlerInterface { public function handle(RecordedEvent $recordedEvent): void; } Use EventHandlerTrait to automatically route events to methods based on class names:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 use Backslash\\EventBus\\EventHandlerInterface; use Backslash\\EventBus\\EventHandlerTrait; class NotificationHandler implements EventHandlerInterface { use EventHandlerTrait; public function __construct( private MailerInterface $mailer, ) { } private function handleStudentSubscribedToCourseEvent( StudentSubscribedToCourseEvent $event, RecordedEvent $recordedEvent, ): void { $this-\u0026gt;mailer-\u0026gt;send( to: $event-\u0026gt;studentId, subject: \u0026#39;Course Subscription Confirmed\u0026#39;, body: \u0026#34;You have been subscribed to course {$event-\u0026gt;courseId}\u0026#34; ); } } The trait looks for methods named by prefixing handle to the event\u0026rsquo;s short class name. It automatically extracts the domain event from the RecordedEvent wrapper and passes both to the handler method.\nHandler method signature# Handler methods follow this pattern:\n1 2 3 4 5 6 private function handleSomeEvent( SomeEvent $event, RecordedEvent $recordedEvent, ): void { // Handler logic } Requirements:\nMethod must be private (or protected if creating an abstract base handler class) First parameter is the domain event with full type information Second parameter is the RecordedEvent wrapper (optional) Must return void The RecordedEvent provides access to metadata and the recording timestamp. Most handlers only need the domain event; use the second parameter when you need metadata like correlation IDs or user context:\n1 2 3 4 5 6 7 8 9 10 11 12 13 private function handleStudentSubscribedToCourseEvent( StudentSubscribedToCourseEvent $event, RecordedEvent $recordedEvent, ): void { $correlationId = $recordedEvent-\u0026gt;getMetadata()-\u0026gt;get(\u0026#39;correlation_id\u0026#39;); $this-\u0026gt;logger-\u0026gt;info(\u0026#39;Student subscribed to course\u0026#39;, [ \u0026#39;correlation_id\u0026#39; =\u0026gt; $correlationId, \u0026#39;student_id\u0026#39; =\u0026gt; $event-\u0026gt;studentId, \u0026#39;course_id\u0026#39; =\u0026gt; $event-\u0026gt;courseId, \u0026#39;timestamp\u0026#39; =\u0026gt; $recordedEvent-\u0026gt;getRecordTime()-\u0026gt;format(\u0026#39;Y-m-d H:i:s\u0026#39;), ]); } Subscribing handlers to events# Register handlers with the EventBus during application bootstrap:\n1 2 $eventBus-\u0026gt;subscribe(CourseDefinedEvent::class, $notificationHandler); $eventBus-\u0026gt;subscribe(StudentRegisteredEvent::class, $notificationHandler); A single handler can respond to multiple event types, and multiple handlers can respond to the same event.\nHandling multiple event types# A single handler class can respond to different events by implementing multiple handler methods:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class CourseNotificationHandler implements EventHandlerInterface { use EventHandlerTrait; public function __construct( private MailerInterface $mailer, private LoggerInterface $logger, ) { } private function handleCourseDefinedEvent( CourseDefinedEvent $event, RecordedEvent $recordedEvent, ): void { $this-\u0026gt;logger-\u0026gt;info(\u0026#39;New course defined\u0026#39;, [ \u0026#39;course_id\u0026#39; =\u0026gt; $event-\u0026gt;courseId, \u0026#39;name\u0026#39; =\u0026gt; $event-\u0026gt;name, ]); } private function handleCourseCapacityChangedEvent( CourseCapacityChangedEvent $event, RecordedEvent $recordedEvent, ): void { $this-\u0026gt;mailer-\u0026gt;sendToAdmins( subject: \u0026#39;Course Capacity Changed\u0026#39;, body: \u0026#34;Course {$event-\u0026gt;courseId} capacity changed from {$event-\u0026gt;previous} to {$event-\u0026gt;new}\u0026#34; ); } private function handleStudentSubscribedToCourseEvent( StudentSubscribedToCourseEvent $event, RecordedEvent $recordedEvent, ): void { $this-\u0026gt;mailer-\u0026gt;send( to: $event-\u0026gt;studentId, subject: \u0026#39;Subscription Confirmed\u0026#39;, body: \u0026#34;You are now enrolled in course {$event-\u0026gt;courseId}\u0026#34; ); } } Register the handler for all relevant events:\n1 2 3 4 5 $handler = new CourseNotificationHandler($mailer, $logger); $eventBus-\u0026gt;subscribe(CourseDefinedEvent::class, $handler); $eventBus-\u0026gt;subscribe(CourseCapacityChangedEvent::class, $handler); $eventBus-\u0026gt;subscribe(StudentSubscribedToCourseEvent::class, $handler); Lazy loading handlers# Avoid instantiating all handlers during bootstrap using EventHandlerProxy:\n1 2 3 4 5 6 use Backslash\\EventBus\\EventHandlerProxy; $eventBus-\u0026gt;subscribe( CourseDefinedEvent::class, new EventHandlerProxy(fn() =\u0026gt; $container-\u0026gt;get(NotificationHandler::class)) ); The proxy defers handler instantiation until the first relevant event is published.\nHandler execution order# Multiple handlers subscribed to the same event execute synchronously in registration order:\n1 2 3 $eventBus-\u0026gt;subscribe(StudentSubscribedToCourseEvent::class, $courseProjector); // First $eventBus-\u0026gt;subscribe(StudentSubscribedToCourseEvent::class, $studentProjector); // Second $eventBus-\u0026gt;subscribe(StudentSubscribedToCourseEvent::class, $emailNotifier); // Third This synchronous execution ensures:\nProjections are updated before the command completes Exceptions propagate immediately Read-your-writes consistency within the same transaction Event handlers execute after events are persisted to the EventStore but before the command handler returns. This guarantees that projections reflect the latest state when the command completes successfully.\nHandling errors in event handlers# Event handlers can choose how to handle errors based on the operation\u0026rsquo;s criticality.\nFor critical operations like projection updates, let exceptions propagate to halt processing:\n1 2 3 4 5 6 7 8 9 10 private function handleCourseDefinedEvent( CourseDefinedEvent $event, RecordedEvent $recordedEvent, ): void { $list = $this-\u0026gt;getList(); $list-\u0026gt;defineCourse($event-\u0026gt;courseId, $event-\u0026gt;name, $event-\u0026gt;capacity); // If storing fails, exception propagates and command fails $this-\u0026gt;projections-\u0026gt;store($list); } For non-critical operations like sending notifications, catch exceptions to prevent blocking:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private function handleStudentSubscribedToCourseEvent( StudentSubscribedToCourseEvent $event, RecordedEvent $recordedEvent, ): void { try { $this-\u0026gt;mailer-\u0026gt;send( to: $event-\u0026gt;studentId, subject: \u0026#39;Subscription Confirmed\u0026#39;, body: $this-\u0026gt;buildMessage($event) ); } catch (MailerException $e) { // Log but don\u0026#39;t halt processing $this-\u0026gt;logger-\u0026gt;warning(\u0026#39;Failed to send notification\u0026#39;, [ \u0026#39;event\u0026#39; =\u0026gt; $event::class, \u0026#39;error\u0026#39; =\u0026gt; $e-\u0026gt;getMessage(), ]); } } Best practices# Keep handlers focused. Each handler should have a single responsibility. Don\u0026rsquo;t mix projection updates with external API calls in the same handler.\nHandle missing data gracefully. If a resource doesn\u0026rsquo;t exist when handling an event, create it or handle the absence appropriately rather than letting the handler fail.\nMake side effects idempotent. External operations like sending emails should be idempotent or use deduplication mechanisms to prevent duplicate actions during replays.\nLet critical failures propagate. For essential operations like projection updates, let exceptions propagate to halt processing.\nCatch non-critical failures. For optional operations like notifications, catch exceptions and log them without blocking the event flow.\nUse metadata when needed. Access the RecordedEvent parameter to retrieve correlation IDs, timestamps, or other metadata for logging and tracing.\nEvent handlers are essential for the read side of your CQRS architecture. The most common use of event handlers is updating projections, which we\u0026rsquo;ll explore in the next section.\n"},{"id":10,"href":"/backslash/cqrs/building-projections/","title":"Building Projections","section":"Commands and Projections (CQRS)","content":"Building Projections# Projections are read-optimized views of your system\u0026rsquo;s state. Unlike Models, which are rebuilt from events to make decisions, projections are designed specifically for querying. They represent the read side of your CQRS architecture.\nProjections are data structures (read models) that represent the current state; projectors are event handlers that update these projections when events occur. This separation keeps projection logic organized and testable.\nProjections work with the ProjectionStore, which handles their persistence and retrieval. We\u0026rsquo;ll cover the ProjectionStore in detail later in this section.\nUnderstanding projections# A projection is a denormalized view built from events. It answers specific questions about your system\u0026rsquo;s state without requiring complex joins or event replay. For example:\nA list of all courses with their current capacity and available seats A student\u0026rsquo;s enrollment history with course details A dashboard showing real-time subscription metrics Projections are updated synchronously after events are published. Because event handlers execute in the same PHP process as command dispatch, projections are immediately consistent with the write side once the command completes.\nProjections are often designed for specific UI needs. They can expose their data in convenient formats like arrays for JSON serialization or XML objects for API responses. This flexibility allows you to tailor each projection to its intended consumer.\nProjections vs Models# The distinction between projections and models is fundamental to CQRS:\nModels (write side):\nRebuilt from events for each decision Enforce business rules Not persisted; exist only during command processing Optimized for making decisions Projections (read side):\nContinuously updated as events occur Persisted for efficient querying No business logic; simple data structures Optimized for reading and display Defining projections# Projections must implement ProjectionInterface:\n1 2 3 4 interface ProjectionInterface { public function getId(): string; } The getId() method returns the projection\u0026rsquo;s identifier. A projection\u0026rsquo;s identity is composed of both its ID and its fully qualified class name, which means two different projection classes can use the same ID without conflict.\nHere\u0026rsquo;s a simple projection example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class CourseProjection implements ProjectionInterface { private string $courseId; private string $name; private int $capacity; public function __construct(string $courseId, string $name, int $capacity) { $this-\u0026gt;courseId = $courseId; $this-\u0026gt;name = $name; $this-\u0026gt;capacity = $capacity; } public function getId(): string { return $this-\u0026gt;courseId; } public function getName(): string { return $this-\u0026gt;name; } public function getCapacity(): int { return $this-\u0026gt;capacity; } public function changeCapacity(int $newCapacity): void { $this-\u0026gt;capacity = $newCapacity; } } This projection represents a course with methods to access its data and update its capacity. Each course gets its own projection instance identified by its course ID.\nExposing projection data# Projections often need to expose their data in formats suitable for APIs or user interfaces. Implement JsonSerializable to control JSON representation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class CourseProjection implements ProjectionInterface, JsonSerializable { private string $courseId; private string $name; private int $capacity; public function __construct(string $courseId, string $name, int $capacity) { $this-\u0026gt;courseId = $courseId; $this-\u0026gt;name = $name; $this-\u0026gt;capacity = $capacity; } public function getId(): string { return $this-\u0026gt;courseId; } public function getName(): string { return $this-\u0026gt;name; } public function getCapacity(): int { return $this-\u0026gt;capacity; } public function changeCapacity(int $newCapacity): void { $this-\u0026gt;capacity = $newCapacity; } public function jsonSerialize(): array { return [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;courseId, \u0026#39;name\u0026#39; =\u0026gt; $this-\u0026gt;name, \u0026#39;capacity\u0026#39; =\u0026gt; $this-\u0026gt;capacity, ]; } } This allows seamless JSON encoding:\n1 2 3 $projection = $projectionStore-\u0026gt;find(\u0026#39;course-123\u0026#39;, CourseProjection::class); $json = json_encode($projection); // {\u0026#34;id\u0026#34;:\u0026#34;course-123\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;PHP Basics\u0026#34;,\u0026#34;capacity\u0026#34;:30} Similarly, projections can provide methods for XML, CSV, or any other format your application needs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public function toXml(): SimpleXMLElement { $xml = new SimpleXMLElement(\u0026#39;\u0026lt;course/\u0026gt;\u0026#39;); $xml-\u0026gt;addChild(\u0026#39;id\u0026#39;, $this-\u0026gt;courseId); $xml-\u0026gt;addChild(\u0026#39;name\u0026#39;, $this-\u0026gt;name); $xml-\u0026gt;addChild(\u0026#39;capacity\u0026#39;, (string) $this-\u0026gt;capacity); return $xml; } public function toArray(): array { return [ \u0026#39;id\u0026#39; =\u0026gt; $this-\u0026gt;courseId, \u0026#39;name\u0026#39; =\u0026gt; $this-\u0026gt;name, \u0026#39;capacity\u0026#39; =\u0026gt; $this-\u0026gt;capacity, ]; } Designing projection structure# Design your projections based on how you need to query them, not how your domain is modeled. A single domain concept might have multiple projections for different use cases.\nMultiple specialized projections may seem redundant, but they enable optimal query performance; each projection can be indexed and structured for its specific access pattern.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // For listing all courses class CourseListItemProjection implements ProjectionInterface { public function __construct( public string $id, public string $name, public int $availableSeats, ) { } public function getId(): string { return $this-\u0026gt;id; } } // For displaying course details class CourseDetailProjection implements ProjectionInterface { public function __construct( public string $id, public string $name, public string $description, public int $capacity, public int $subscribedCount, public array $subscribedStudents, ) { } public function getId(): string { return $this-\u0026gt;id; } } // For analytics class CourseMetricsProjection implements ProjectionInterface { public function __construct( public string $id, public int $totalSubscriptions, public int $totalUnsubscriptions, public float $averageSubscriptionDuration, ) { } public function getId(): string { return $this-\u0026gt;id; } } Each projection is tailored to answer specific queries efficiently.\nWorking with ProjectionStore# The ProjectionStore is responsible for persisting and retrieving projections. It uses an adapter to interact with the underlying storage mechanism.\nBackslash provides two built-in adapters:\nPdoProjectionStoreAdapter: For PDO-compatible databases (MySQL, SQLite); suitable for production use InMemoryProjectionStoreAdapter: In-memory storage; useful for testing with the Scenario component Developers can build custom adapters for other storage engines like MongoDB, Redis, or even a file system by implementing the AdapterInterface.\nSetting up the ProjectionStore# Create a ProjectionStore instance with a storage adapter during your application\u0026rsquo;s bootstrap:\n1 2 3 4 5 6 $pdo = new PdoProxy(fn() =\u0026gt; new PDO(\u0026#39;mysql:host=localhost;dbname=myapp\u0026#39;, \u0026#39;user\u0026#39;, \u0026#39;pass\u0026#39;)); $serializer = new Serializer(new SerializeFunctionSerializer()); $config = new Config(); $adapter = new PdoProjectionStoreAdapter($pdo, $serializer, $config); $projectionStore = new ProjectionStore($adapter); The PdoProjectionStoreAdapter requires:\nPDO connection: Database connection via PdoProxy or direct PDO instance Serializer: Converts projections to/from storage format; SerializeFunctionSerializer uses PHP\u0026rsquo;s native serialize() function Config (optional): Allows customization of database column names via withTable() and withAlias() methods Example with custom configuration:\n1 2 3 4 5 6 7 $config = (new Config()) -\u0026gt;withTable(\u0026#39;my_projections\u0026#39;) -\u0026gt;withAlias(\u0026#39;projection_id\u0026#39;, \u0026#39;id\u0026#39;) -\u0026gt;withAlias(\u0026#39;projection_class\u0026#39;, \u0026#39;type\u0026#39;) -\u0026gt;withAlias(\u0026#39;projection_payload\u0026#39;, \u0026#39;data\u0026#39;); $adapter = new PdoProjectionStoreAdapter($pdo, $serializer, $config); For testing, use the InMemoryProjectionStoreAdapter:\n1 2 $adapter = new InMemoryProjectionStoreAdapter(); $projectionStore = new ProjectionStore($adapter); This adapter stores projections in memory, making it fast and isolated for test scenarios.\nCommitting automatically after command handling# Backslash provides ProjectionStoreTransactionCommandDispatcherMiddleware, a command dispatcher middleware that manages projection transactions automatically. It wraps the command dispatch process in a transaction and calls commit() on the ProjectionStore when the command completes successfully. If an exception occurs during command processing, the middleware calls rollback() to discard buffered changes.\n1 2 3 4 5 use Backslash\\ProjectionStoreTransactionCommandDispatcherMiddleware\\ProjectionStoreTransactionCommandDispatcherMiddleware; $dispatcher-\u0026gt;addMiddleware( new ProjectionStoreTransactionCommandDispatcherMiddleware($projectionStore) ); This middleware is typically added to the command dispatcher during application bootstrap, ensuring all commands benefit from automatic transaction management without requiring explicit commit/rollback calls in command handlers.\nCreating projectors# Projectors are event handlers that update projections. Here\u0026rsquo;s a complete example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class CourseProjector implements EventHandlerInterface { use EventHandlerTrait; public function __construct( private ProjectionStoreInterface $projections, ) { } private function handleCourseDefinedEvent( CourseDefinedEvent $event, RecordedEvent $recordedEvent, ): void { $projection = new CourseProjection( $event-\u0026gt;courseId, $event-\u0026gt;name, $event-\u0026gt;capacity ); $this-\u0026gt;projections-\u0026gt;store($projection); } private function handleCourseCapacityChangedEvent( CourseCapacityChangedEvent $event, RecordedEvent $recordedEvent, ): void { try { $projection = $this-\u0026gt;projections-\u0026gt;find( $event-\u0026gt;courseId, CourseProjection::class ); $projection-\u0026gt;changeCapacity($event-\u0026gt;new); $this-\u0026gt;projections-\u0026gt;store($projection); } catch (ProjectionNotFoundException) { // Log or handle missing projection } } } Register the projector with the EventBus:\n1 2 3 4 $projector = new CourseProjector($projectionStore); $eventBus-\u0026gt;subscribe(CourseDefinedEvent::class, $projector); $eventBus-\u0026gt;subscribe(CourseCapacityChangedEvent::class, $projector); Querying projections# Once projections are persisted, you can query them in your application or UI layer:\n1 2 3 4 5 6 7 // In a request handler or controller public function handle(ServerRequestInterface $request): ResponseInterface { $courseId = $request-\u0026gt;getAttribute(\u0026#39;courseId\u0026#39;); $projection = $this-\u0026gt;projectionStore-\u0026gt;find($courseId, CourseProjection::class) return new JsonResponse($projection); } This separation between write operations (commands updating models) and read operations (queries fetching projections) is the essence of CQRS.\nBest practices# Design for queries. Structure projections based on how you need to query them, not how your domain is modeled.\nCreate multiple projections. Don\u0026rsquo;t try to create one projection that serves all queries. Build specialized projections for different use cases.\nUse buffering for consistency. The buffering mechanism enables batch updates and transactional consistency. Use middleware to manage commit/rollback automatically.\nKeep projections simple. Projections should be dumb data structures. Complex logic belongs in the projectors that update them.\nKeep projectors autonomous. Projectors should only read and modify the projections they own; avoid reading other projections. If you need data from multiple projections, create a new combined projection instead.\nOptimize for reads. Precompute values, denormalize data, and structure projections to make queries fast.\nOne projection instance per entity. Each entity (course, student, etc.) should have its own projection instance with a unique ID.\nMake projections serializable. Projections must be serializable for persistence. Use simple types and avoid circular references.\n"},{"id":11,"href":"/backslash/testing/setting-up-tests/","title":"Setting Up Tests","section":"Testing Your Application","content":"Setting Up Tests# Testing event-sourced applications requires specific infrastructure setup. This section shows how to configure PHPUnit and create a base test case for your Backslash application.\nInstalling PHPUnit# Add PHPUnit to your project:\n1 composer require --dev phpunit/phpunit Creating phpunit.xml# Create a phpunit.xml configuration file in your project root:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;phpunit xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:noNamespaceSchemaLocation=\u0026#34;vendor/phpunit/phpunit/phpunit.xsd\u0026#34; bootstrap=\u0026#34;vendor/autoload.php\u0026#34; colors=\u0026#34;true\u0026#34; verbose=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;testsuites\u0026gt; \u0026lt;testsuite name=\u0026#34;Application Tests\u0026#34;\u0026gt; \u0026lt;directory\u0026gt;tests\u0026lt;/directory\u0026gt; \u0026lt;/testsuite\u0026gt; \u0026lt;/testsuites\u0026gt; \u0026lt;php\u0026gt; \u0026lt;env name=\u0026#34;TESTING\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;env name=\u0026#34;PDO_DSN\u0026#34; value=\u0026#34;sqlite:memory:\u0026#34;/\u0026gt; \u0026lt;/php\u0026gt; \u0026lt;/phpunit\u0026gt; Creating a base test case# Create an abstract base test case that sets up the infrastructure components needed for testing. The primary goal is to instantiate a Scenario object, which will be used by test scenarios explained in section 13.\nThe way you obtain Backslash components depends heavily on how your application is structured. Most PHP applications use a dependency injection container. Here\u0026rsquo;s an example using a PSR-11 container:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 \u0026lt;?php declare(strict_types=1); namespace Tests; use Backslash\\CommandDispatcher\\DispatcherInterface; use Backslash\\EventBus\\EventBusInterface; use Backslash\\PdoEventStore\\Config; use Backslash\\PdoEventStore\\Driver; use Backslash\\ProjectionStore\\ProjectionStoreInterface; use Backslash\\Scenario\\AssertionsTrait; use Backslash\\Scenario\\Scenario; use PDO; use PHPUnit\\Framework\\TestCase as PHPUnitTestCase; use Psr\\Container\\ContainerInterface; abstract class TestCase extends PHPUnitTestCase { use AssertionsTrait; protected Scenario $scenario; private ContainerInterface $container; public function setUp(): void { parent::setUp(); // Bootstrap your DI container $this-\u0026gt;container = require __DIR__ . \u0026#39;/../bootstrap.php\u0026#39;; // Get PDO SQLite instance – Make sure your DI container uses the PDO_DSN variable in phpunit.xml when running tests! $pdo = $this-\u0026gt;container-\u0026gt;get(PDO::class); // Create table for the EventStore $pdo-\u0026gt;exec(Driver::SQLITE-\u0026gt;buildCreateTableStatement(new Config())); // Create Scenario instance with required dependencies $this-\u0026gt;scenario = new Scenario( $this-\u0026gt;container-\u0026gt;get(EventBusInterface::class), $this-\u0026gt;container-\u0026gt;get(DispatcherInterface::class), // Your DI container must use the InMemoryProjectionStoreAdapter when running tests. $this-\u0026gt;container-\u0026gt;get(ProjectionStoreInterface::class), $this-\u0026gt;container-\u0026gt;get(EventStoreInterface::class) ); // Set up initial test data $this-\u0026gt;createInitialTestData(); } private function createInitialTestData(): void { $dispatcher = $this-\u0026gt;container-\u0026gt;get(DispatcherInterface::class); // Dispatch commands to generate data used by test scenarios // Example: $dispatcher-\u0026gt;dispatch(new RegisterUserCommand(\u0026#39;user-1\u0026#39;, \u0026#39;John\u0026#39;, \u0026#39;Smith\u0026#39;)); } } This base test case provides:\nContainer bootstrap: Loads the application\u0026rsquo;s dependency injection container Database setup: Creates EventStore tables using the SQLite driver; Driver::SQLITE generates the appropriate CREATE TABLE statement, while Config allows customization of table and column names if needed In-memory SQLite: Fast and isolated; each test gets a fresh database without external dependencies Scenario instance: Ready-to-use Scenario with EventBus, Dispatcher, and ProjectionStore AssertionsTrait: Provides scenario-specific assertions like assertPublishedEventsContain(), assertPublishedEventsCount(), and assertUpdatedProjectionsContain(), which will be covered in section 13 Initial test data: Optional createInitialTestData() method to set up common fixtures shared across tests; use this to create baseline data like system users or default configurations, avoiding duplication in individual tests "},{"id":12,"href":"/backslash/testing/writing-test-scenarios/","title":"Writing Test Scenarios","section":"Testing Your Application","content":"Writing Test Scenarios# The Scenario component provides a fluent, behavior-driven interface for testing event-sourced applications. It uses the Play class to define test scenarios in a readable, expressive manner.\nUnderstanding scenarios# Scenarios test the complete flow from command dispatch through event publication to projection updates. They verify that commands produce the expected events and that projections are updated correctly.\nThe Scenario class was instantiated in your base test case (section 12). Each test creates Play instances and executes them via scenario-\u0026gt;play().\nA scenario can execute multiple plays sequentially, similar to acts in a theater piece. Each play represents a distinct phase of the test, and subsequent plays see the effects of previous plays.\nWriting basic scenarios with Play# Create test scenarios using the Play class. A Play defines:\nInitial state via withInitialEvents() or withInitialCommands() Actions via dispatch() or doAction() Assertions via testEvents(), testProjections(), or testThat() Expected exceptions via expectException() or expectExceptionMessage() The order of these methods matters: setup methods should come first, followed by actions, then assertions.\nHere\u0026rsquo;s a basic example:\n1 2 3 4 5 6 7 8 9 10 11 12 public function test_registering_student_publishes_event(): void { $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;dispatch(new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;John\u0026#39;)) -\u0026gt;testEvents(function (PublishedEvents $events) { $this-\u0026gt;assertPublishedEventsContainExactly([ StudentRegisteredEvent::class =\u0026gt; 1, ], $events); }) ); } Setting up initial state# Use withInitialCommands() to establish state by dispatching commands before the test action:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;withInitialCommands( new DefineCourseCommand(\u0026#39;123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 10), new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;Alice\u0026#39;) ) -\u0026gt;dispatch(new SubscribeStudentToCourseCommand(\u0026#39;1\u0026#39;, \u0026#39;123\u0026#39;)) -\u0026gt;testEvents(function (PublishedEvents $events) { $this-\u0026gt;assertPublishedEventsContain( StudentSubscribedToCourseEvent::class, $events ); }) ); Commands passed to withInitialCommands() are dispatched before the main test action, setting up the required initial state.\nUse withInitialEvents() to directly publish events for initial state:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 use Backslash\\Event\\RecordedEventStream; $initialEvents = new RecordedEventStream([ new RecordedEvent( new CourseDefinedEvent(\u0026#39;123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 10), new Metadata([]), new DateTimeImmutable() ), ]); $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;withInitialEvents($initialEvents) -\u0026gt;dispatch(new ChangeCourseCapacityCommand(\u0026#39;123\u0026#39;, 20)) -\u0026gt;testEvents(function (PublishedEvents $events) { $this-\u0026gt;assertPublishedEventsContain( CourseCapacityChangedEvent::class, $events ); }) ); Dispatching commands# Use dispatch() to execute one or more commands:\n1 2 3 4 5 6 7 8 9 10 $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;dispatch( new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;John\u0026#39;), new RegisterStudentCommand(\u0026#39;2\u0026#39;, \u0026#39;Alice\u0026#39;) ) -\u0026gt;testEvents(function (PublishedEvents $events) { $this-\u0026gt;assertPublishedEventsCount(2, $events); }) ); Commands are dispatched through the normal command handling flow, including all middleware and handlers.\nExecuting actions# Use doAction() to execute arbitrary code during the test. Common use cases include:\nDefining constants or variables needed by subsequent assertions Setting up mocks or stubs Manipulating time or other external dependencies Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;withInitialCommands(new DefineCourseCommand(\u0026#39;123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 10)) -\u0026gt;doAction(function () { // Define a constant for use in later assertions define(\u0026#39;MY_CONSTANT\u0026#39;, \u0026#39;some-value\u0026#39;); }) -\u0026gt;dispatch(new ChangeCourseCapacityCommand(\u0026#39;123\u0026#39;, 20)) -\u0026gt;testEvents(function (PublishedEvents $events) { $this-\u0026gt;assertPublishedEventsCount(1, $events); }) -\u0026gt;testThat(function () { // Verify the constant was defined $this-\u0026gt;assertTrue(defined(\u0026#39;MY_CONSTANT\u0026#39;)); }) ); Actions execute in the order they\u0026rsquo;re defined relative to commands.\nAsserting on published events# Use testEvents() to verify which events were published:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;dispatch(new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;John\u0026#39;)) -\u0026gt;testEvents(function (PublishedEvents $events) { // Assert specific event was published $this-\u0026gt;assertPublishedEventsContain( StudentRegisteredEvent::class, $events ); // Assert event count $this-\u0026gt;assertPublishedEventsCount(1, $events); // Assert exact event types and counts $this-\u0026gt;assertPublishedEventsContainExactly([ StudentRegisteredEvent::class =\u0026gt; 1, ], $events); }) ); The testEvents() callback receives a PublishedEvents object containing all events published **during this play only **. Events from previous plays or initial setup are not included in this collection.\nAsserting on updated projections# Use testProjections() to verify which projections were updated:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;withInitialCommands( new DefineCourseCommand(\u0026#39;123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 10), new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;John\u0026#39;) ) -\u0026gt;dispatch(new SubscribeStudentToCourseCommand(\u0026#39;1\u0026#39;, \u0026#39;123\u0026#39;)) -\u0026gt;testProjections(function (UpdatedProjections $projections) { // Assert specific projection was updated $this-\u0026gt;assertUpdatedProjectionsContain( StudentListProjection::class, $projections ); // Access updated projections $studentList = $projections-\u0026gt;getAllOf(StudentListProjection::class)[0]; $this-\u0026gt;assertStringContainsString(\u0026#39;John (PHP Basics)\u0026#39;, (string) $studentList); }) ); The testProjections() callback receives an UpdatedProjections object containing projections modified during this play only. Projections updated in previous plays are not included.\nUse getAllOf() to retrieve all updated projections of a specific type. This returns an array because multiple projection instances of the same class can be updated in a single play (for example, updating both CourseProjection for course-123 and CourseProjection for course-456). Access individual projections by array index.\nCustom assertions# Use testThat() for custom assertion logic:\n1 2 3 4 5 6 7 8 9 10 11 $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;dispatch(new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;John\u0026#39;)) -\u0026gt;testThat(function () { $projection = $this-\u0026gt;projectionStore-\u0026gt;find( StudentListProjection::ID, StudentListProjection::class ); $this-\u0026gt;assertStringContainsString(\u0026#39;John\u0026#39;, (string) $projection); }) ); The testThat() callback executes after commands and actions, allowing arbitrary assertions.\nTesting business rule violations# Test that commands throw exceptions using expectException():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public function test_cannot_subscribe_to_full_course(): void { $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;expectException(CourseAtFullCapacityException::class) -\u0026gt;withInitialCommands( new DefineCourseCommand(\u0026#39;123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 1), new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;John\u0026#39;), new RegisterStudentCommand(\u0026#39;2\u0026#39;, \u0026#39;Alice\u0026#39;), new SubscribeStudentToCourseCommand(\u0026#39;1\u0026#39;, \u0026#39;123\u0026#39;) ) -\u0026gt;dispatch(new SubscribeStudentToCourseCommand(\u0026#39;2\u0026#39;, \u0026#39;123\u0026#39;)) ); } When expectException() is used, the test passes only if the expected exception is thrown. Use the @doesNotPerformAssertions PHPUnit annotation to avoid warnings; PHPUnit expects at least one assertion per test, but with expectException() alone, PHPUnit doesn\u0026rsquo;t recognize it as an assertion, so the annotation tells PHPUnit this is intentional.\nTest for specific exception messages using expectExceptionMessage():\n1 2 3 4 5 6 7 8 9 10 11 $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;expectExceptionMessage(\u0026#39;Course is at full capacity\u0026#39;) -\u0026gt;withInitialCommands( new DefineCourseCommand(\u0026#39;123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 1), new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;John\u0026#39;), new RegisterStudentCommand(\u0026#39;2\u0026#39;, \u0026#39;Alice\u0026#39;), new SubscribeStudentToCourseCommand(\u0026#39;1\u0026#39;, \u0026#39;123\u0026#39;) ) -\u0026gt;dispatch(new SubscribeStudentToCourseCommand(\u0026#39;2\u0026#39;, \u0026#39;123\u0026#39;)) ); Chaining multiple plays# A scenario can execute multiple plays sequentially, like acts in a theater piece. Each play represents a distinct phase of the test:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public function test_subscription_lifecycle(): void { $subscribe = new Play() -\u0026gt;withInitialCommands( new DefineCourseCommand(\u0026#39;123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 10), new RegisterStudentCommand(\u0026#39;1\u0026#39;, \u0026#39;John\u0026#39;) ) -\u0026gt;dispatch(new SubscribeStudentToCourseCommand(\u0026#39;1\u0026#39;, \u0026#39;123\u0026#39;)) -\u0026gt;testEvents(function (PublishedEvents $events) { $this-\u0026gt;assertPublishedEventsContain( StudentSubscribedToCourseEvent::class, $events ); }); $unsubscribe = new Play() -\u0026gt;dispatch(new UnsubscribeStudentFromCourseCommand(\u0026#39;1\u0026#39;, \u0026#39;123\u0026#39;)) -\u0026gt;testEvents(function (PublishedEvents $events) { $this-\u0026gt;assertPublishedEventsContain( StudentUnsubscribedFromCourseEvent::class, $events ); }); $this-\u0026gt;scenario-\u0026gt;play($subscribe, $unsubscribe); } Each play executes in order, like acts in a theater piece. The second play (unsubscribe) sees all the effects of the first play (subscribe), including published events and updated projections. This allows you to test multi-step workflows while keeping each phase clearly defined and testable.\nComplete scenario example# Here\u0026rsquo;s a comprehensive example demonstrating all Play features and assertions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public function test_subscription_workflow(): void { $studentId = \u0026#39;1\u0026#39;; $courseId = \u0026#39;2\u0026#39;; $subscribe = new Play() -\u0026gt;withInitialEvents( new RecordedEventStream( RecordedEvent::create( new CourseDefinedEvent($courseId, \u0026#39;Maths\u0026#39;, 30), new Metadata(), new DateTimeImmutable(), ), ), ) -\u0026gt;withInitialCommands( new RegisterStudentCommand($studentId, \u0026#39;John\u0026#39;), ) -\u0026gt;dispatch( new SubscribeStudentToCourseCommand($studentId, $courseId), ) -\u0026gt;doAction(function (): void { define(\u0026#39;MY_CONSTANT\u0026#39;, \u0026#39;some-value\u0026#39;); }) -\u0026gt;testEvents(function (PublishedEvents $events) use ($studentId, $courseId): void { $this-\u0026gt;assertPublishedEventsCount(1, $events); $this-\u0026gt;assertPublishedEventsContainOnly(StudentSubscribedToCourseEvent::class, $events); $this-\u0026gt;assertPublishedEventsDoNotContain(StudentUnsubscribedFromCourseEvent::class, $events); /** @var StudentSubscribedToCourseEvent $event */ $event = $events-\u0026gt;getAllOf(StudentSubscribedToCourseEvent::class)[0]-\u0026gt;getEvent(); $this-\u0026gt;assertEquals($studentId, $event-\u0026gt;studentId); $this-\u0026gt;assertEquals($courseId, $event-\u0026gt;courseId); }) -\u0026gt;testProjections(function (UpdatedProjections $projections): void { $this-\u0026gt;assertUpdatedProjectionsCount(2, $projections); $this-\u0026gt;assertUpdatedProjectionsContainExactly([ CourseListProjection::class =\u0026gt; 1, StudentListProjection::class =\u0026gt; 1, ], $projections); }) -\u0026gt;testThat(function (): void { defined(\u0026#39;MY_CONSTANT\u0026#39;); }); $unsubscribe = new Play() -\u0026gt;dispatch( new UnsubscribeStudentFromCourseCommand($studentId, $courseId), ) -\u0026gt;testEvents(function (PublishedEvents $events) use ($studentId, $courseId): void { $this-\u0026gt;assertPublishedEventsContainExactly([ StudentUnsubscribedFromCourseEvent::class =\u0026gt; 1, ], $events); }); $oops = new Play() -\u0026gt;expectException(StudentNotSubscribedToCourseException::class) -\u0026gt;dispatch( new UnsubscribeStudentFromCourseCommand($studentId, $courseId), ); $this-\u0026gt;scenario-\u0026gt;play( $subscribe, $unsubscribe, $oops, ); } This example demonstrates:\nwithInitialEvents(): Setting up state with a RecordedEventStream withInitialCommands(): Dispatching commands for initial setup dispatch(): Executing the main test command doAction(): Running arbitrary code during the test testEvents(): Comprehensive event assertions including count, type, and content verification testProjections(): Verifying projection updates with exact counts testThat(): Custom assertion logic expectException(): Testing business rule violations Multiple plays: Three sequential plays representing different phases of the workflow Using AssertionsTrait# The AssertionsTrait (included in your base test case) provides helpful assertions for working with scenarios:\nEvent assertions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Assert an event was published $this-\u0026gt;assertPublishedEventsContain(CourseDefinedEvent::class, $events); // Assert only a specific event type was published $this-\u0026gt;assertPublishedEventsContainOnly(CourseDefinedEvent::class, $events); // Assert exact count of specific events $this-\u0026gt;assertPublishedEventsContainExactly([ CourseDefinedEvent::class =\u0026gt; 1, CourseCapacityChangedEvent::class =\u0026gt; 2, ], $events); // Assert total event count $this-\u0026gt;assertPublishedEventsCount(3, $events); // Assert an event was NOT published $this-\u0026gt;assertPublishedEventsDoNotContain(CourseDeletedEvent::class, $events); Projection assertions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Assert a projection was updated $this-\u0026gt;assertUpdatedProjectionsContain(CourseProjection::class, $projections); // Assert only a specific projection type was updated $this-\u0026gt;assertUpdatedProjectionsContainOnly(CourseProjection::class, $projections); // Assert exact count of updated projections $this-\u0026gt;assertUpdatedProjectionsContainExactly([ CourseProjection::class =\u0026gt; 1, StudentProjection::class =\u0026gt; 2, ], $projections); // Assert total projection update count $this-\u0026gt;assertUpdatedProjectionsCount(3, $projections); Chaining Play methods# All Play methods return a new instance, allowing fluent chaining:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $this-\u0026gt;scenario-\u0026gt;play( new Play() -\u0026gt;withInitialCommands(new DefineCourseCommand(\u0026#39;123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 10)) -\u0026gt;dispatch(new ChangeCourseCapacityCommand(\u0026#39;123\u0026#39;, 20)) -\u0026gt;testEvents(function (PublishedEvents $events) { $this-\u0026gt;assertPublishedEventsCount(1, $events); }) -\u0026gt;testProjections(function (UpdatedProjections $projections) { $this-\u0026gt;assertUpdatedProjectionsContain(CourseProjection::class, $projections); }) -\u0026gt;testThat(function () { $projection = $this-\u0026gt;projectionStore-\u0026gt;find(\u0026#39;123\u0026#39;, CourseProjection::class); $this-\u0026gt;assertEquals(20, $projection-\u0026gt;getCapacity()); }) ); Testing models in isolation# You can test models directly without scenarios for unit-level tests:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public function test_course_capacity_model_enforces_rules(): void { $model = new CourseCapacityModel(); // Apply initial state $initialEvents = new RecordedEventStream( RecordedEvent::create( new CourseDefinedEvent(\u0026#39;course-123\u0026#39;, \u0026#39;PHP Basics\u0026#39;, 10), new Metadata(), new DateTimeImmutable() ) ); $model-\u0026gt;applyEvents($initialEvents); // Execute business logic $model-\u0026gt;change(20); // Assert recorded events $changes = $model-\u0026gt;getChanges(); $this-\u0026gt;assertCount(1, $changes); $recordedEvent = iterator_to_array($changes)[0]; $this-\u0026gt;assertInstanceOf(CourseCapacityChangedEvent::class, $recordedEvent-\u0026gt;getEvent()); } This approach tests model logic in isolation without involving the command dispatcher, event bus, or projections. Use applyEvents() with a RecordedEventStream to set up the model\u0026rsquo;s initial state, just like withInitialEvents() in scenarios.\nBest practices# Set up state with withInitialCommands(). Use withInitialCommands() to establish initial state rather than manipulating stores directly; this ensures events are published and projections are updated correctly.\nKeep scenarios focused. Each test should verify one behavior; avoid testing multiple unrelated behaviors in a single scenario.\nTest both success and failure. Write scenarios for both successful operations and business rule violations using expectException().\nLeverage AssertionsTrait. Use the provided assertions (assertPublishedEventsContain(), assertUpdatedProjectionsContain()) rather than writing custom assertion logic.\nChain multiple plays for workflows. When testing multi-step processes, create separate plays for each step and execute them together via scenario-\u0026gt;play($play1, $play2).\nUse @doesNotPerformAssertions for exception tests. When using expectException() without additional assertions, add the @doesNotPerformAssertions PHPUnit annotation to avoid warnings.\n"},{"id":13,"href":"/backslash/customization/extending-with-middleware/","title":"Extending with Middleware","section":"Customization","content":"Extending with Middleware# Middleware provides a powerful way to add cross-cutting concerns to Backslash components. It follows an onion layer model, allowing logic to be executed before and after core operations.\nUnderstanding middleware# Middleware wraps component operations in layers. Each middleware can:\nExecute logic before delegating to the next layer Execute logic after the next layer completes Transform inputs or outputs Handle errors or side effects The onion layer model ensures symmetric execution:\nOuter Layer → Middle Layer → Inner Layer → [Core] → Inner Layer → Middle Layer → Outer LayerMultiple Backslash core components support middleware extension:\nDispatcher EventBus EventNameResolver EventStore ProjectionStore Repository Serializer (dependency of ProjectionStore and EventStore for serializing projections and events to text) CommandDispatcher middleware# Dispatcher middleware wraps command dispatch. Common use cases include logging commands or handling errors:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 use Backslash\\CommandDispatcher\\DispatcherInterface; use Backslash\\CommandDispatcher\\MiddlewareInterface; class LoggingCommandDispatcherMiddleware implements MiddlewareInterface { public function __construct( private LoggerInterface $logger, ) { } public function dispatch(object $command, DispatcherInterface $next): void { $this-\u0026gt;logger-\u0026gt;info(\u0026#39;Dispatching command\u0026#39;, [ \u0026#39;command\u0026#39; =\u0026gt; $command::class, ]); try { $next-\u0026gt;dispatch($command); $this-\u0026gt;logger-\u0026gt;info(\u0026#39;Command completed successfully\u0026#39;); } catch (Throwable $e) { $this-\u0026gt;logger-\u0026gt;error(\u0026#39;Command failed\u0026#39;, [ \u0026#39;error\u0026#39; =\u0026gt; $e-\u0026gt;getMessage(), ]); throw $e; } } } Register it with the dispatcher:\n1 $dispatcher-\u0026gt;addMiddleware(new LoggingCommandDispatcherMiddleware($logger)); EventStore middleware# EventStore middleware wraps access to the storage adapter.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 use Backslash\\EventStore\\MiddlewareInterface; use Backslash\\EventStore\\EventStoreInterface; use Backslash\\Event\\RecordedEventStream; use Backslash\\EventStore\\Query\\QueryInterface; class StreamEnricherEventStoreMiddleware implements MiddlewareInterface { public function __construct( private StreamEnricherInterface $enricher, ) { } public function append( RecordedEventStream $stream, ?QueryInterface $concurrencyCheck, ?int $expectedSequence, EventStoreInterface $next ): void { $enrichedStream = $this-\u0026gt;enricher-\u0026gt;enrich($stream); $next-\u0026gt;append($enrichedStream, $concurrencyCheck, $expectedSequence); } public function fetch( ?QueryInterface $query, int $fromSequence, EventStoreInterface $next ): StoredRecordedEventStream { return $next-\u0026gt;fetch($query, $fromSequence); } public function inspect(InspectorInterface $inspector, EventStoreInterface $next): void { $next-\u0026gt;inspect($inspector); } public function purge(EventStoreInterface $next): void { $next-\u0026gt;purge(); } } Register it with the EventStore:\n1 $eventStore-\u0026gt;addMiddleware(new StreamEnricherEventStoreMiddleware($enricher)); EventBus middleware# EventBus middleware wraps event publishing. Common use cases include enriching events before broadcasting them:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 use Backslash\\EventBus\\MiddlewareInterface; use Backslash\\EventBus\\EventBusInterface; use Backslash\\Event\\RecordedEventStream; class StreamEnricherEventBusMiddleware implements MiddlewareInterface { public function __construct( private StreamEnricherInterface $enricher, ) { } public function publish( RecordedEventStream $stream, EventBusInterface $next ): void { $enrichedStream = $this-\u0026gt;enricher-\u0026gt;enrich($stream); $next-\u0026gt;publish($enrichedStream); } } Register it with the EventBus:\n1 $eventBus-\u0026gt;addMiddleware(new StreamEnricherEventBusMiddleware($enricher)); ProjectionStore middleware# ProjectionStore middleware wraps access to the storage adapter.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 use Backslash\\ProjectionStore\\MiddlewareInterface; use Backslash\\ProjectionStore\\ProjectionStoreInterface; use Backslash\\Projection\\ProjectionInterface; class LoggingProjectionStoreMiddleware implements MiddlewareInterface { public function __construct( private LoggerInterface $logger, ) { } public function find(string $id, string $class, ProjectionStoreInterface $next): ProjectionInterface { $this-\u0026gt;logger-\u0026gt;debug(\u0026#39;Loading projection\u0026#39;, [\u0026#39;id\u0026#39; =\u0026gt; $id, \u0026#39;class\u0026#39; =\u0026gt; $class]); return $next-\u0026gt;find($id, $class); } public function has(string $id, string $class, ProjectionStoreInterface $next): bool { return $next-\u0026gt;has($id, $class); } public function store(ProjectionInterface $projection, ProjectionStoreInterface $next): void { $this-\u0026gt;logger-\u0026gt;debug(\u0026#39;Storing projection\u0026#39;, [\u0026#39;class\u0026#39; =\u0026gt; $projection::class]); $next-\u0026gt;store($projection); } // Implement other required methods... } Repository middleware# Repository middleware wraps model loading and changes persistence. Common use cases include modifying queries to apply additional conditions, such as tenant scoping in multi-tenant applications.\nThe following example shows a middleware that adds tenant filtering to all queries, avoiding the need to repeat this condition in every query throughout the application:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 use Backslash\\Repository\\MiddlewareInterface; use Backslash\\Repository\\RepositoryInterface; use Backslash\\Model\\ModelInterface; use Backslash\\EventStore\\Query\\QueryInterface; use Backslash\\EventStore\\Query\\Metadata; class TenantScopingRepositoryMiddleware implements MiddlewareInterface { public function __construct( private string $tenantId, ) { } public function loadModel( string $modelClass, ?QueryInterface $query, RepositoryInterface $next ): ModelInterface { // Add tenant filtering to query $scopedQuery = $query?-\u0026gt;and(Metadata::is(\u0026#39;tenant_id\u0026#39;, $this-\u0026gt;tenantId)); return $next-\u0026gt;loadModel($modelClass, $scopedQuery); } public function storeChanges(ModelInterface $model, RepositoryInterface $next): void { $next-\u0026gt;storeChanges($model); } } Built-in middleware# Backslash provides several ready-to-use middleware:\nCacheProjectionStoreMiddleware - Caches loaded projections in memory to avoid unnecessary storage communication, significantly improving performance when projections are accessed multiple times:\n1 2 3 use Backslash\\CacheProjectionStoreMiddleware\\CacheProjectionStoreMiddleware; $projectionStore-\u0026gt;addMiddleware(new CacheProjectionStoreMiddleware()); PdoTransactionCommandDispatcherMiddleware - Creates a PDO transaction for command dispatch; rolls back if an exception occurs to prevent new events from being written to the database:\n1 2 3 use Backslash\\PdoTransactionCommandDispatcherMiddleware\\PdoTransactionCommandDispatcherMiddleware; $dispatcher-\u0026gt;addMiddleware(new PdoTransactionCommandDispatcherMiddleware($pdo)); ProjectionStoreTransactionCommandDispatcherMiddleware - Calls commit() on ProjectionStore after command processing completes successfully:\n1 2 3 4 5 use Backslash\\ProjectionStoreTransactionCommandDispatcherMiddleware\\ProjectionStoreTransactionCommandDispatcherMiddleware; $dispatcher-\u0026gt;addMiddleware( new ProjectionStoreTransactionCommandDispatcherMiddleware($projectionStore) ); StreamEnricherEventBusMiddleware - Enriches events before publishing to EventBus:\n1 2 3 use Backslash\\StreamEnricher\\StreamEnricherEventBusMiddleware; $eventBus-\u0026gt;addMiddleware(new StreamEnricherEventBusMiddleware($enricher)); StreamEnricherEventStoreMiddleware - Enriches events before persisting to EventStore:\n1 2 3 use Backslash\\StreamEnricher\\StreamEnricherEventStoreMiddleware; $eventStore-\u0026gt;addMiddleware(new StreamEnricherEventStoreMiddleware($enricher)); Middleware execution order# Middleware executes in reverse order of registration (LIFO - Last In, First Out). The last middleware added executes first:\n1 2 3 $dispatcher-\u0026gt;addMiddleware($logging); // Executes third (innermost) $dispatcher-\u0026gt;addMiddleware($validation); // Executes second $dispatcher-\u0026gt;addMiddleware($transaction); // Executes first (outermost) When a command is dispatched:\nTransaction middleware starts transaction Validation middleware validates command Logging middleware logs the command Command handler executes Logging middleware logs completion Validation middleware completes Transaction middleware commits This onion-layer pattern ensures middleware executes symmetrically before and after the core operation.\nHere\u0026rsquo;s a concrete example using Backslash\u0026rsquo;s built-in middleware:\n1 2 3 4 5 6 7 use Backslash\\ProjectionStoreTransactionCommandDispatcherMiddleware\\ProjectionStoreTransactionCommandDispatcherMiddleware; use Backslash\\PdoTransactionCommandDispatcherMiddleware\\PdoTransactionCommandDispatcherMiddleware; // Order matters: PDO transaction wraps everything $dispatcher-\u0026gt;addMiddleware(new LoggingMiddleware($logger)); // Innermost $dispatcher-\u0026gt;addMiddleware(new ProjectionStoreTransactionCommandDispatcherMiddleware($projectionStore)); // Middle $dispatcher-\u0026gt;addMiddleware(new PdoTransactionCommandDispatcherMiddleware($pdo)); // Outermost Execution flow:\nPDO transaction begins ProjectionStore prepares for changes Logging records command Command executes, events are persisted Logging records completion ProjectionStore commits buffered projections PDO transaction commits Best practices# Keep middleware focused. Each middleware should handle a single concern; avoid creating god middleware that handles multiple responsibilities.\nMake middleware reusable. Write middleware that works with any component of its type, not just specific use cases.\nConsider execution order. Add middleware in the correct order based on dependencies; transactions should wrap validation, validation should wrap logging, etc.\nHandle exceptions appropriately. Middleware can catch and transform exceptions, but be careful not to swallow important errors that should propagate to callers.\nTest middleware independently. Middleware should be testable in isolation from the components they wrap.\nDocument side effects. If middleware modifies state or has side effects, document this clearly in comments or documentation.\nUse built-in middleware when available. Backslash provides common middleware implementations; use them instead of rolling your own.\n"},{"id":14,"href":"/backslash/customization/enriching-event-streams/","title":"Enriching Event Streams","section":"Customization","content":"Enriching Event Streams# Event stream enrichment allows applications to inject metadata into events as they flow through the system. This metadata provides contextual information like the current tenant, authenticated user, or correlation keys.\nEnrichment occurs after the model records events but before they are persisted to EventStore or published to EventBus.\nUnderstanding stream enrichment# An application should have a single implementation of StreamEnricherInterface:\n1 2 3 4 interface StreamEnricherInterface { public function enrich(RecordedEventStream $stream): RecordedEventStream; } Using a single enricher avoids metadata conflicts, ensures predictable execution order, and simplifies configuration. The enricher\u0026rsquo;s role is to inject metadata into events. This implementation can receive services as dependencies when contextual information is needed. Common metadata includes:\nCurrent tenant in multi-tenant applications Authenticated user information Correlation IDs for request tracing Execution context (batch job, API request, CLI command) Creating a stream enricher# Here\u0026rsquo;s an example enricher that adds tenant and user information:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 use Backslash\\StreamEnricher\\StreamEnricherInterface; use Backslash\\Event\\RecordedEventStream; use Backslash\\Event\\RecordedEvent; class StreamEnricher implements StreamEnricherInterface { public function __construct( private TenantService $tenantService, private AuthService $authService, private CorrelationIdService $correlationService, ) { } public function enrich(RecordedEventStream $stream): RecordedEventStream { $enrichedStream = new RecordedEventStream(); foreach ($stream-\u0026gt;getRecordedEvents() as $recordedEvent) { $metadata = $recordedEvent-\u0026gt;getMetadata(); // Add tenant information if ($this-\u0026gt;tenantService-\u0026gt;hasTenant()) { $metadata = $metadata-\u0026gt;with(\u0026#39;tenant_id\u0026#39;, $this-\u0026gt;tenantService-\u0026gt;getCurrentTenantId()); } // Add authenticated user if ($this-\u0026gt;authService-\u0026gt;isAuthenticated()) { $metadata = $metadata-\u0026gt;with(\u0026#39;user_id\u0026#39;, $this-\u0026gt;authService-\u0026gt;getCurrentUserId()); } // Add correlation ID for tracing $metadata = $metadata-\u0026gt;with(\u0026#39;correlation_id\u0026#39;, $this-\u0026gt;correlationService-\u0026gt;get()); $enrichedStream = $enrichedStream-\u0026gt;withRecordedEvents( $recordedEvent-\u0026gt;withMetadata($metadata) ); } return $enrichedStream; } } This enricher receives services as dependencies and uses them to inject relevant metadata into every event.\nRegistering the enricher# Backslash provides two middleware for stream enrichment, as introduced in section 14:\nStreamEnricherEventStoreMiddleware: Enriches events before persisting to EventStore StreamEnricherEventBusMiddleware: Enriches events before publishing to EventBus Register both middleware during application bootstrap to ensure consistent metadata in storage and when published:\n1 2 3 4 5 6 7 8 9 10 use Backslash\\StreamEnricher\\StreamEnricherEventStoreMiddleware; use Backslash\\StreamEnricher\\StreamEnricherEventBusMiddleware; $enricher = new StreamEnricher($tenantService, $authService, $correlationService); // Enrich before persisting $eventStore-\u0026gt;addMiddleware(new StreamEnricherEventStoreMiddleware($enricher)); // Enrich before publishing $eventBus-\u0026gt;addMiddleware(new StreamEnricherEventBusMiddleware($enricher)); Using enriched metadata# Enriched metadata becomes available throughout the application. Event handlers can access this metadata to make decisions or add context:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class NotificationHandler implements EventHandlerInterface { use EventHandlerTrait; private function handleStudentSubscribedToCourseEvent( StudentSubscribedToCourseEvent $event, RecordedEvent $recordedEvent, ): void { $metadata = $recordedEvent-\u0026gt;getMetadata(); // Access enriched tenant information $tenantId = $metadata-\u0026gt;get(\u0026#39;tenant_id\u0026#39;); // Access correlation ID for tracing $correlationId = $metadata-\u0026gt;get(\u0026#39;correlation_id\u0026#39;); $this-\u0026gt;logger-\u0026gt;info(\u0026#39;Student subscribed\u0026#39;, [ \u0026#39;tenant_id\u0026#39; =\u0026gt; $tenantId, \u0026#39;correlation_id\u0026#39; =\u0026gt; $correlationId, \u0026#39;student_id\u0026#39; =\u0026gt; $event-\u0026gt;studentId, ]); // Send notification with tenant context $this-\u0026gt;notifier-\u0026gt;send($event-\u0026gt;studentId, $tenantId); } } Queries can also filter events based on enriched metadata:\n1 2 3 4 5 use Backslash\\EventStore\\Query\\Metadata; // Load only events for specific tenant $query = EventClass::is(CourseDefinedEvent::class) -\u0026gt;and(Metadata::is(\u0026#39;tenant_id\u0026#39;, $currentTenantId)); Best practices# Use one enricher per application. Create a single StreamEnricherInterface implementation that handles all metadata injection; avoid multiple enrichers with overlapping concerns.\nInject services as dependencies when needed. If the enricher requires contextual information, pass services like authentication, tenant management, or correlation tracking as constructor dependencies rather than accessing global state.\nRegister both middleware. Always register StreamEnricherEventStoreMiddleware and StreamEnricherEventBusMiddleware to ensure metadata consistency between persisted events and published events.\nEnrich metadata, not payloads. Event payloads should contain domain information; metadata is for technical concerns like tenant context, user information, or correlation IDs.\nAvoid sensitive data. Metadata is stored and potentially logged; avoid adding passwords, tokens, or other sensitive information unless absolutely required.\nKeep enrichment fast. Enrichment runs for every event; avoid expensive operations like database queries or external API calls.\n"},{"id":15,"href":"/backslash/application-setup/defining-services/","title":"Defining Services","section":"Application Setup","content":"Defining Services# Using a dependency injection container is beneficial for bootstrapping Backslash applications. The number of components and their dependencies makes a container practical for managing instantiation and wiring.\nThe demo application implements its own PSR-11 container in src/Infrastructure/Container.php for demonstration purposes. In production applications, prefer using your framework\u0026rsquo;s built-in container (Laravel, Symfony, Slim, etc.) or a dedicated container library like php-di/php-di or league/container. These mature containers provide features like auto-wiring, configuration caching, and better performance.\nThis section shows how to define Backslash components as services in your dependency injection container.\nUnderstanding Backslash interfaces# Backslash provides an interface for each component. These interfaces serve as contracts that define what operations each component supports, independent of their concrete implementations.\nThe core interfaces include:\nDispatcherInterface for command dispatching EventBusInterface for event publishing and subscription EventStoreInterface for event persistence and retrieval ProjectionStoreInterface for projection storage and querying RepositoryInterface for model loading and persistence SerializerInterface for object serialization StreamEnricherInterface for metadata enrichment PdoInterface for PDO connections Services depend on interfaces rather than concrete implementations, making code more flexible and testable:\n1 2 3 4 5 6 7 class CourseCommandHandler { public function __construct( private RepositoryInterface $repository, // Depends on interface ) { } } This approach allows you to swap implementations without changing dependent code. For testing, you can inject mock implementations; for production, you inject the real implementations configured in your container.\nService definition patterns# Most containers support defining services through configuration files, PHP arrays, or using auto-wiring. The examples below use closure-based definitions compatible with most PSR-11 containers:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Simple service with no dependencies StreamEnricherInterface::class =\u0026gt; fn () =\u0026gt; new StreamEnricher(), // Service with container-resolved dependencies RepositoryInterface::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new Repository( $c-\u0026gt;get(EventStoreInterface::class), $c-\u0026gt;get(EventBusInterface::class), ), // Service with configuration PdoInterface::class =\u0026gt; function () { $dsn = getenv(\u0026#39;DB_DSN\u0026#39;) ?: \u0026#39;sqlite:data/demo.sqlite\u0026#39;; return new PdoProxy(fn () =\u0026gt; new PDO($dsn)); }, Adapt these patterns to your container\u0026rsquo;s preferred configuration format. All Backslash components should be registered as singleton services; instances should be shared and reused throughout your application.\nConfiguring the PDO connection# Define the database connection as a service:\n1 2 3 4 5 6 7 8 9 10 use Backslash\\Pdo\\PdoInterface; use Backslash\\Pdo\\PdoProxy; PdoInterface::class =\u0026gt; function () { $dsn = getenv(\u0026#39;DB_DSN\u0026#39;) ?: \u0026#39;sqlite:data/demo.sqlite\u0026#39;; $username = getenv(\u0026#39;DB_USERNAME\u0026#39;) ?: null; $password = getenv(\u0026#39;DB_PASSWORD\u0026#39;) ?: null; return new PdoProxy(fn () =\u0026gt; new PDO($dsn, $username, $password)); }, The PdoProxy defers the actual PDO connection until the first database operation.\nUse environment variables for database configuration to keep credentials out of code and support different environments.\nConfiguring the EventStore# Define the EventStore with its adapter and middleware:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 use Backslash\\EventNameResolver\\EventNameResolver; use Backslash\\EventNameResolver\\MatchingClassEventNameResolverAdapter; use Backslash\\EventStore\\EventStore; use Backslash\\EventStore\\EventStoreInterface; use Backslash\\PdoEventStore\\PdoEventStoreAdapter; use Backslash\\PdoEventStore\\Config as PdoEventStoreConfig; use Backslash\\Serializer\\Serializer; use Backslash\\PdoEventStore\\JsonEventSerializer; use Backslash\\PdoEventStore\\JsonIdentifiersSerializer; use Backslash\\PdoEventStore\\JsonMetadataSerializer; use Backslash\\StreamEnricher\\StreamEnricherEventStoreMiddleware; use Ramsey\\Uuid\\Uuid; EventStoreInterface::class =\u0026gt; function (ContainerInterface $c) { $eventNameResolver = new EventNameResolver(new MatchingClassEventNameResolverAdapter()); $store = new EventStore( new PdoEventStoreAdapter( $c-\u0026gt;get(PdoInterface::class), new PdoEventStoreConfig(), $eventNameResolver, new Serializer(new JsonEventSerializer($eventNameResolver)), new Serializer(new JsonIdentifiersSerializer()), new Serializer(new JsonMetadataSerializer()), fn () =\u0026gt; Uuid::uuid4()-\u0026gt;toString(), ), ); $store-\u0026gt;addMiddleware( new StreamEnricherEventStoreMiddleware( $c-\u0026gt;get(StreamEnricherInterface::class) ) ); return $store; }, The EventStore requires an adapter (PdoEventStoreAdapter), serializers for events, identifiers, and metadata, and a function to generate event IDs.\nAdd the StreamEnricherEventStoreMiddleware to inject metadata into events as they\u0026rsquo;re persisted.\nConfiguring the ProjectionStore# Define the ProjectionStore with its adapter and middleware:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 use Backslash\\ProjectionStore\\ProjectionStore; use Backslash\\ProjectionStore\\ProjectionStoreInterface; use Backslash\\PdoProjectionStore\\PdoProjectionStoreAdapter; use Backslash\\PdoProjectionStore\\Config as PdoProjectionStoreConfig; use Backslash\\Serializer\\SerializeFunctionSerializer; use Backslash\\CacheProjectionStoreMiddleware\\CacheProjectionStoreMiddleware; ProjectionStoreInterface::class =\u0026gt; function (ContainerInterface $c) { $store = new ProjectionStore( new PdoProjectionStoreAdapter( $c-\u0026gt;get(PdoInterface::class), new Serializer(new SerializeFunctionSerializer()), new PdoProjectionStoreConfig(), ), ); $store-\u0026gt;addMiddleware(new CacheProjectionStoreMiddleware()); return $store; }, The ProjectionStore requires an adapter (PdoProjectionStoreAdapter), a serializer, and configuration.\nAdd the CacheProjectionStoreMiddleware to cache projections in memory and reduce database queries.\nFor testing purposes, you can easily swap the adapter for an in-memory implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 use Backslash\\InMemoryProjectionStore\\InMemoryProjectionStoreAdapter; ProjectionStoreInterface::class =\u0026gt; function (ContainerInterface $c) { $isTestMode = (bool) getenv(\u0026#39;TESTING\u0026#39;); $adapter = $isTestMode ? new InMemoryProjectionStoreAdapter() : new PdoProjectionStoreAdapter( $c-\u0026gt;get(PdoInterface::class), new Serializer(new SerializeFunctionSerializer()), new PdoProjectionStoreConfig(), ); $store = new ProjectionStore($adapter); $store-\u0026gt;addMiddleware(new CacheProjectionStoreMiddleware()); return $store; }, This approach allows tests to run faster without database dependencies while using the same service definition.\nConfiguring the Repository# Define the Repository with its dependencies:\n1 2 3 4 5 6 7 use Backslash\\Repository\\Repository; use Backslash\\Repository\\RepositoryInterface; RepositoryInterface::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new Repository( $c-\u0026gt;get(EventStoreInterface::class), $c-\u0026gt;get(EventBusInterface::class), ), The Repository requires the EventStore for loading and persisting events, and the EventBus for publishing events after persistence.\nConfiguring the EventBus# Define the EventBus with its middleware:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 use Backslash\\EventBus\\EventBus; use Backslash\\EventBus\\EventBusInterface; use Backslash\\StreamEnricher\\StreamEnricherEventBusMiddleware; EventBusInterface::class =\u0026gt; function (ContainerInterface $c) { $bus = new EventBus(); $bus-\u0026gt;addMiddleware( new StreamEnricherEventBusMiddleware( $c-\u0026gt;get(StreamEnricherInterface::class) ) ); return $bus; }, Add the StreamEnricherEventBusMiddleware to inject metadata into events as they\u0026rsquo;re published, ensuring consistency with persisted events.\nEvent handler registration (subscribing event handlers to events) does not happen here; it occurs during the boot process explained in section 17.\nConfiguring the Dispatcher# Define the Dispatcher with its middleware:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 use Backslash\\CommandDispatcher\\Dispatcher; use Backslash\\CommandDispatcher\\DispatcherInterface; use Backslash\\PdoTransactionCommandDispatcherMiddleware\\PdoTransactionCommandDispatcherMiddleware; use Backslash\\ProjectionStoreTransactionCommandDispatcherMiddleware\\ProjectionStoreTransactionCommandDispatcherMiddleware; DispatcherInterface::class =\u0026gt; function (ContainerInterface $c) { $dispatcher = new Dispatcher(); $dispatcher-\u0026gt;addMiddleware( new PdoTransactionCommandDispatcherMiddleware( $c-\u0026gt;get(PdoInterface::class) ) ); $dispatcher-\u0026gt;addMiddleware( new ProjectionStoreTransactionCommandDispatcherMiddleware( $c-\u0026gt;get(ProjectionStoreInterface::class) ) ); return $dispatcher; }, Add the PdoTransactionCommandDispatcherMiddleware to wrap command execution in a database transaction.\nAdd the ProjectionStoreTransactionCommandDispatcherMiddleware to automatically commit projections on success and rollback on failure.\nCommand handler registration does not happen here; it occurs during the boot process explained in section 17.\nConfiguring the StreamEnricher# Define the StreamEnricher implementation:\n1 2 3 use Backslash\\StreamEnricher\\StreamEnricherInterface; StreamEnricherInterface::class =\u0026gt; fn () =\u0026gt; new AppStreamEnricher(), If your enricher requires dependencies like authentication services or tenant management, inject them through the constructor:\n1 2 3 4 StreamEnricherInterface::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new AppStreamEnricher( $c-\u0026gt;get(AuthenticationService::class), $c-\u0026gt;get(TenantContext::class), ), Configuring handlers and projectors# Define each command handler, event handler, and projector as services:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Command Handlers CourseCommandHandler::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new CourseCommandHandler( $c-\u0026gt;get(RepositoryInterface::class), ), StudentCommandHandler::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new StudentCommandHandler( $c-\u0026gt;get(RepositoryInterface::class), ), SubscriptionCommandHandler::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new SubscriptionCommandHandler( $c-\u0026gt;get(RepositoryInterface::class), ), // Projectors CourseListProjector::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new CourseListProjector( $c-\u0026gt;get(ProjectionStoreInterface::class), ), StudentListProjector::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new StudentListProjector( $c-\u0026gt;get(ProjectionStoreInterface::class), ), // Processors NotificationProcessor::class =\u0026gt; fn (ContainerInterface $c) =\u0026gt; new NotificationProcessor( $c-\u0026gt;get(MailerInterface::class), ), Each handler definition injects its required dependencies through the constructor.\n"},{"id":16,"href":"/backslash/application-setup/registering-handlers/","title":"Registering Handlers","section":"Application Setup","content":"Registering Handlers# The boot process registers commands with the dispatcher and events with the event bus, establishing the routing between messages and their handlers. This registration happens after service definitions are loaded but before the application handles any requests or executes commands.\nUnderstanding the boot process# The boot process consists of:\nRegistering commands with command handlers in the dispatcher Registering events with projectors in the event bus Registering events with processors in the event bus (skipped during projection rebuilds) This registration should happen once during application startup.\nCommand and event handler mappings are defined statically (typically as class constants) and used during the boot process to perform the actual registration.\nDefining command handler mappings# Define command handler mappings using an associative array:\n1 2 3 4 5 6 7 8 9 10 11 12 13 private const COMMAND_HANDLERS = [ CourseCommandHandler::class =\u0026gt; [ ChangeCourseCapacityCommand::class, DefineCourseCommand::class, ], StudentCommandHandler::class =\u0026gt; [ RegisterStudentCommand::class, ], SubscriptionCommandHandler::class =\u0026gt; [ SubscribeStudentToCourseCommand::class, UnsubscribeStudentFromCourseCommand::class, ], ]; Each command handler class maps to an array of command classes it handles.\nAlternatively, implement a static getHandledCommands() method on each command handler to make the mapping explicit:\n1 2 3 4 5 6 7 8 9 10 11 12 class CourseCommandHandler { public static function getHandledCommands(): array { return [ ChangeCourseCapacityCommand::class, DefineCourseCommand::class, ]; } // Handler methods... } This approach makes each handler explicitly declare what it handles, eliminating the need for a centralized mapping array.\nDefining event handler mappings# Define event handler mappings, separating projectors from processors:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private const PROJECTORS = [ CourseListProjector::class =\u0026gt; [ CourseDefinedEvent::class, CourseCapacityChangedEvent::class, StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, ], StudentListProjector::class =\u0026gt; [ CourseDefinedEvent::class, StudentRegisteredEvent::class, StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, ], ]; private const PROCESSORS = [ NotificationProcessor::class =\u0026gt; [ StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, ], EmailProcessor::class =\u0026gt; [ StudentRegisteredEvent::class, ], ]; Maintain separate lists for projectors and processors to enable selective registration.\nAlternatively, implement a static getSubscribedEvents() method on each event handler to make the mapping explicit:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class CourseListProjector { public static function getSubscribedEvents(): array { return [ CourseDefinedEvent::class, CourseCapacityChangedEvent::class, StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, ]; } // Handler methods... } This approach makes each handler explicitly declare what events it subscribes to, eliminating the need for centralized mapping arrays.\nUsing handler discovery# When using the static method approach (getHandledCommands() and getSubscribedEvents()), the boot process can discover and register handlers automatically:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // List of all command handler classes $commandHandlerClasses = [ CourseCommandHandler::class, StudentCommandHandler::class, SubscriptionCommandHandler::class, ]; // Register command handlers using discovery foreach ($commandHandlerClasses as $handlerClass) { $commands = $handlerClass::getHandledCommands(); foreach ($commands as $commandClass) { $container-\u0026gt;get(DispatcherInterface::class)-\u0026gt;registerHandler( $commandClass, new HandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($handlerClass)) ); } } // List of all event handler classes $projectorClasses = [ CourseListProjector::class, StudentListProjector::class, ]; $processorClasses = [ NotificationProcessor::class, EmailProcessor::class, ]; // Register projectors using discovery foreach ($projectorClasses as $projectorClass) { $events = $projectorClass::getSubscribedEvents(); foreach ($events as $eventClass) { $container-\u0026gt;get(EventBusInterface::class)-\u0026gt;subscribe( $eventClass, new EventHandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($projectorClass)) ); } } // Register processors (skip during projection rebuilds) $isRebuildMode = (bool) getenv(\u0026#39;REBUILD_PROJECTIONS\u0026#39;); if (!$isRebuildMode) { foreach ($processorClasses as $processorClass) { $events = $processorClass::getSubscribedEvents(); foreach ($events as $eventClass) { $container-\u0026gt;get(EventBusInterface::class)-\u0026gt;subscribe( $eventClass, new EventHandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($processorClass)) ); } } } This discovery approach requires maintaining only a list of handler classes rather than complete mappings, reducing duplication since each handler already declares what it handles.\nUsing HandlerProxy and EventHandlerProxy# Backslash provides proxy classes that defer handler instantiation:\nHandlerProxy for command handlers:\n1 2 3 4 5 6 use Backslash\\CommandDispatcher\\HandlerProxy; $dispatcher-\u0026gt;registerHandler( DefineCourseCommand::class, new HandlerProxy(fn () =\u0026gt; $container-\u0026gt;get(CourseCommandHandler::class)) ); EventHandlerProxy for event handlers:\n1 2 3 4 5 6 use Backslash\\EventBus\\EventHandlerProxy; $eventBus-\u0026gt;subscribe( CourseDefinedEvent::class, new EventHandlerProxy(fn () =\u0026gt; $container-\u0026gt;get(CourseListProjector::class)) ); These proxies defer handler instantiation until they\u0026rsquo;re actually needed.\nRegistering command handlers# The boot process registers command handlers with the dispatcher:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 use Backslash\\CommandDispatcher\\DispatcherInterface; use Backslash\\CommandDispatcher\\HandlerProxy; /** @var DispatcherInterface $dispatcher */ $dispatcher = $container-\u0026gt;get(DispatcherInterface::class); foreach (COMMAND_HANDLERS as $handlerClass =\u0026gt; $commandClasses) { foreach ($commandClasses as $commandClass) { $dispatcher-\u0026gt;registerHandler( $commandClass, new HandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($handlerClass)) ); } } This registration happens during boot, before dispatching any commands.\nRegistering event handlers# The boot process registers event handlers with the event bus:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 use Backslash\\EventBus\\EventBusInterface; use Backslash\\EventBus\\EventHandlerProxy; /** @var EventBusInterface $eventBus */ $eventBus = $container-\u0026gt;get(EventBusInterface::class); // Register projectors foreach (PROJECTORS as $projectorClass =\u0026gt; $eventClasses) { foreach ($eventClasses as $eventClass) { $eventBus-\u0026gt;subscribe( $eventClass, new EventHandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($projectorClass)) ); } } // Register processors (skip during projection rebuilds) $isRebuildMode = (bool) getenv(\u0026#39;REBUILD_PROJECTIONS\u0026#39;); if (!$isRebuildMode) { foreach (PROCESSORS as $processorClass =\u0026gt; $eventClasses) { foreach ($eventClasses as $eventClass) { $eventBus-\u0026gt;subscribe( $eventClass, new EventHandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($processorClass)) ); } } } The application determines whether it\u0026rsquo;s in rebuild mode (typically using an environment variable like REBUILD_PROJECTIONS). During projection rebuilds, processors are not registered to avoid triggering side effects like sending duplicate notifications or making external API calls.\n"},{"id":17,"href":"/backslash/application-setup/using-the-bootstrap-file/","title":"Using the Bootstrap File","section":"Application Setup","content":"Using the Bootstrap File# The bootstrap file provides a single entry point for configuring your container and booting your application. This file can be included in CLI scripts, web applications, and tests to ensure consistent initialization.\nCreating the bootstrap file# Create a bootstrap.php file at your project root:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 \u0026lt;?php declare(strict_types=1); namespace MyApp; use Backslash\\CommandDispatcher\\DispatcherInterface; use Backslash\\CommandDispatcher\\HandlerProxy; use Backslash\\EventBus\\EventBusInterface; use Backslash\\EventBus\\EventHandlerProxy; use Psr\\Container\\ContainerInterface; return (function (): ContainerInterface { const COMMAND_HANDLERS = [ CourseCommandHandler::class =\u0026gt; [ ChangeCourseCapacityCommand::class, DefineCourseCommand::class, ], StudentCommandHandler::class =\u0026gt; [ RegisterStudentCommand::class, ], SubscriptionCommandHandler::class =\u0026gt; [ SubscribeStudentToCourseCommand::class, UnsubscribeStudentFromCourseCommand::class, ], ]; const PROJECTORS = [ CourseListProjector::class =\u0026gt; [ CourseDefinedEvent::class, CourseCapacityChangedEvent::class, StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, ], StudentListProjector::class =\u0026gt; [ CourseDefinedEvent::class, StudentRegisteredEvent::class, StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, ], ]; const PROCESSORS = [ NotificationProcessor::class =\u0026gt; [ StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, ], EmailProcessor::class =\u0026gt; [ StudentRegisteredEvent::class, ], ]; chdir(__DIR__); require \u0026#39;vendor/autoload.php\u0026#39;; // Load application configuration $config = include \u0026#39;config.php\u0026#39;; // Get your framework\u0026#39;s container or instantiate your own implementation /** @var ContainerInterface $container */ $container = new MyAppContainer($config); // Boot process: register command handlers foreach (COMMAND_HANDLERS as $handlerClass =\u0026gt; $commandClasses) { foreach ($commandClasses as $commandClass) { $container-\u0026gt;get(DispatcherInterface::class)-\u0026gt;registerHandler( $commandClass, new HandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($handlerClass)) ); } } // Boot process: register event handlers foreach (PROJECTORS as $projectorClass =\u0026gt; $eventClasses) { foreach ($eventClasses as $eventClass) { $container-\u0026gt;get(EventBusInterface::class)-\u0026gt;subscribe( $eventClass, new EventHandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($projectorClass)) ); } } // Register processors (skip during projection rebuilds) $isRebuildMode = (bool) getenv(\u0026#39;REBUILD_PROJECTIONS\u0026#39;); if (!$isRebuildMode) { foreach (PROCESSORS as $processorClass =\u0026gt; $eventClasses) { foreach ($eventClasses as $eventClass) { $container-\u0026gt;get(EventBusInterface::class)-\u0026gt;subscribe( $eventClass, new EventHandlerProxy(fn () =\u0026gt; $container-\u0026gt;get($processorClass)) ); } } } return $container; })(); This file loads the autoloader, retrieves the configured container, executes the boot process, and returns the ready-to-use container.\nUsing in CLI scripts# Include the bootstrap in command-line scripts:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php declare(strict_types=1); use Psr\\Container\\ContainerInterface; use Backslash\\CommandDispatcher\\DispatcherInterface; use Demo\\Application\\Command\\Course\\DefineCourseCommand; /** @var ContainerInterface $container */ $container = require __DIR__ . \u0026#39;/../bootstrap.php\u0026#39;; /** @var DispatcherInterface $dispatcher */ $dispatcher = $container-\u0026gt;get(DispatcherInterface::class); // Execute commands $dispatcher-\u0026gt;dispatch(new DefineCourseCommand(\u0026#39;101\u0026#39;, \u0026#39;Introduction to PHP\u0026#39;, 30)); $dispatcher-\u0026gt;dispatch(new DefineCourseCommand(\u0026#39;102\u0026#39;, \u0026#39;Advanced PHP\u0026#39;, 20)); echo \u0026#34;Courses created successfully\\n\u0026#34;; This pattern makes all components available for administrative tasks, data imports, or cron jobs.\nUsing in web applications# Include the bootstrap in your web entry point (e.g., public/index.php).\nHere\u0026rsquo;s an example using Slim Framework:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;?php declare(strict_types=1); use Psr\\Container\\ContainerInterface; use Slim\\Factory\\AppFactory; /** @var ContainerInterface $container */ $container = require __DIR__ . \u0026#39;/../bootstrap.php\u0026#39;; // Set container to create App with on AppFactory AppFactory::setContainer($container); $app = AppFactory::create(); // Define routes $app-\u0026gt;get(\u0026#39;/students/{id}\u0026#39;, function ($request, $response) use ($container) { $projectionStore = $container-\u0026gt;get(ProjectionStoreInterface::class); $student = $projectionStore-\u0026gt;find( $request-\u0026gt;getAttribute(\u0026#39;id\u0026#39;), StudentProjection::class ); $response-\u0026gt;getBody()-\u0026gt;write(json_encode($student)); return $response-\u0026gt;withHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json\u0026#39;); }); $app-\u0026gt;post(\u0026#39;/courses\u0026#39;, function ($request, $response) use ($container) { $data = $request-\u0026gt;getParsedBody(); $dispatcher = $container-\u0026gt;get(DispatcherInterface::class); $dispatcher-\u0026gt;dispatch( new DefineCourseCommand($data[\u0026#39;id\u0026#39;], $data[\u0026#39;name\u0026#39;], $data[\u0026#39;capacity\u0026#39;]) ); return $response-\u0026gt;withStatus(201); }); // Run application $app-\u0026gt;run(); The bootstrap provides all services needed to handle HTTP requests.\nUsing in tests# Include the bootstrap in your test base class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;?php namespace Tests; use Backslash\\CommandDispatcher\\DispatcherInterface; use Backslash\\EventBus\\EventBusInterface; use Backslash\\EventStore\\EventStoreInterface; use Backslash\\ProjectionStore\\ProjectionStoreInterface; use Backslash\\Scenario\\Scenario; use Backslash\\Scenario\\AssertionsTrait; use PHPUnit\\Framework\\TestCase as PHPUnitTestCase; use Psr\\Container\\ContainerInterface; abstract class TestCase extends PHPUnitTestCase { use AssertionsTrait; protected Scenario $scenario; private ContainerInterface $container; public function setUp(): void { parent::setUp(); /** @var ContainerInterface $container */ $this-\u0026gt;container = require __DIR__ . \u0026#39;/../bootstrap.php\u0026#39;; $this-\u0026gt;scenario = new Scenario( $this-\u0026gt;container-\u0026gt;get(EventBusInterface::class), $this-\u0026gt;container-\u0026gt;get(DispatcherInterface::class), $this-\u0026gt;container-\u0026gt;get(ProjectionStoreInterface::class), $this-\u0026gt;container-\u0026gt;get(EventStoreInterface::class), ); } } Tests use the same bootstrap as production, ensuring consistency.\nBest practices# Use your framework\u0026rsquo;s container. If your application uses a framework like Laravel or Symfony, use its built-in container rather than implementing your own.\nUse established container libraries. For framework-agnostic applications, use mature containers like php-di/php-di or league/container that provide auto-wiring and performance optimizations.\nKeep bootstrap centralized. All component configuration and boot logic should be accessible from the bootstrap file.\nUse environment variables. Keep environment-specific settings like database credentials and API keys out of code.\nUse the same bootstrap everywhere. CLI scripts, web entry points, and tests should all use the same bootstrap file to ensure consistency.\nExecute boot once. The boot process (handler registration) should happen once during application initialization, not on every request.\n"},{"id":18,"href":"/backslash/maintenance/rebuilding-projections/","title":"Rebuilding Projections","section":"Maintenance","content":"Rebuilding Projections# Rebuilding projections is a routine task in event-sourced applications. This capability allows you to reconstruct read models from scratch by replaying the complete event history.\nBackslash does not provide a built-in component specifically for rebuilding projections; each application has unique requirements and should implement rebuilding according to its specific needs. However, Backslash provides essential tools that facilitate the rebuild process, such as the Inspector for replaying events, the ProjectionStore for managing projection lifecycle, and the EventBus for routing events to projectors.\nUnderstanding when to rebuild# Rebuild projections when:\nCreating new projections: New read models need historical data from existing events Modifying projection logic: Changes to how projections interpret events require rebuilding with the updated logic Optimizing projection structure: Performance improvements or schema changes necessitate reconstruction Fixing projection bugs: Corrected projector logic must be applied to all historical events Migrating projection storage: Moving projections to different storage systems requires rebuilding in the new location Treating projections as disposable# Because events are the source of truth, projections are disposable and easily reconstructed. Events represent what actually happened in your system; projections are merely interpretations of those events. While projections may occasionally contain errors due to bugs in projector logic, events always tell the truth.\nThis fundamental principle means you can confidently delete and rebuild projections whenever needed. The ability to rebuild projections is what makes CQRS practical for evolving systems.\nDistinguishing projectors from processors# Before rebuilding, understand the critical difference between two types of event handlers:\nProjectors update projections by reading events and storing read models. They are idempotent and side-effect-free beyond projection updates. Examples include:\nBuilding course lists from CourseDefinedEvent Updating student enrollments from StudentSubscribedToCourseEvent Maintaining dashboard metrics from various events Processors trigger side effects like sending notifications, calling external APIs, or publishing to message queues. They should not execute during rebuilds. Examples include:\nSending confirmation emails when students subscribe to courses Notifying external systems of state changes Publishing events to message brokers During rebuilds, register only projectors; never register processors. Processors should execute only once when events first occur, not during historical replays.\nUnderstanding EventStore and Inspector# Normal operations use the Repository to load models and persist changes. Rebuilding requires direct access to the EventStore and EventBus using the Inspector component.\nThe EventStore provides an append-only, queryable log of all events. The Inspector iterates through stored events and publishes them to the EventBus:\n1 2 3 4 use Backslash\\StreamPublishingInspection\\Inspector; $inspector = new Inspector($eventBus); $eventStore-\u0026gt;inspect($inspector); This replays every event in the EventStore, triggering all registered event handlers as if the events were just published.\nFiltering events during replay# The Inspector optionally accepts a Query as its second constructor argument to retrieve only a subset of events from the EventStore. This is particularly useful when rebuilding a single projector; you can pass a query that selects only events relevant to that projector:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use Backslash\\StreamPublishingInspection\\Inspector; use Backslash\\EventStore\\Query\\EventClass; // Define which events the projector needs $relevantEvents = [ CourseDefinedEvent::class, CourseCapacityChangedEvent::class, StudentSubscribedToCourseEvent::class, ]; // Create a query filtering for these events only $query = EventClass::in($relevantEvents); // Inspector will only replay these specific events $inspector = new Inspector($eventBus, $query); $eventStore-\u0026gt;inspect($inspector); Without a query parameter, the Inspector replays all events in the EventStore. When rebuilding all projections, omit the query; when rebuilding specific projections, use EventClass::in() to filter for only the necessary events.\nTracking rebuild progress# The Inspector optionally accepts third and fourth constructor arguments as closures for tracking rebuild progress. The first closure executes before dispatching each event to the EventBus; the second executes after dispatch:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $eventCount = 0; $totalEvents = $eventStore-\u0026gt;count(); // Hypothetical method $beforeDispatch = function (RecordedEvent $recordedEvent) use (\u0026amp;$eventCount, $totalEvents) { $eventCount++; echo sprintf( \u0026#34;Processing event %d/%d: %s\\n\u0026#34;, $eventCount, $totalEvents, $recordedEvent-\u0026gt;getEvent()::class ); }; $afterDispatch = function (RecordedEvent $recordedEvent) { // Log completion, update progress bar, etc. }; $inspector = new Inspector($eventBus, $query, $beforeDispatch, $afterDispatch); $eventStore-\u0026gt;inspect($inspector); These callbacks are particularly useful for outputting progress to the console, calculating completion percentages, or logging rebuild metrics.\nThe serial rebuild process# Rebuilding follows these steps:\nBootstrap the application with only projectors registered; exclude all processors to prevent side effects Delete existing projections by calling purge() on the ProjectionStore Disable stream enricher if your application uses one; metadata enrichment must not occur during replays Load all events chronologically from the EventStore and publish them to the EventBus using Inspector Commit rebuilt projections by calling commit() on the ProjectionStore The serial approach processes events sequentially, looping through all events one after the other in a single PHP process. Here\u0026rsquo;s a complete serial rebuild implementation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;?php declare(strict_types=1); use Backslash\\CommandDispatcher\\DispatcherInterface; use Backslash\\EventBus\\EventBusInterface; use Backslash\\EventStore\\EventStoreInterface; use Backslash\\ProjectionStore\\ProjectionStoreInterface; use Backslash\\StreamPublishingInspection\\Inspector; use Demo\\UI\\Projection\\CourseList\\CourseListProjector; use Demo\\UI\\Projection\\StudentList\\StudentListProjector; use Psr\\Container\\ContainerInterface; /** @var ContainerInterface $container */ $container = require __DIR__ . \u0026#39;/../bootstrap.php\u0026#39;; /** @var EventStoreInterface $eventStore */ $eventStore = $container-\u0026gt;get(EventStoreInterface::class); /** @var ProjectionStoreInterface $projectionStore */ $projectionStore = $container-\u0026gt;get(ProjectionStoreInterface::class); // Create a dedicated EventBus with only projectors $eventBus = new EventBus(); // Register projectors (not processors) $courseListProjector = new CourseListProjector($projectionStore); $studentListProjector = new StudentListProjector($projectionStore); $eventBus-\u0026gt;subscribe(CourseDefinedEvent::class, $courseListProjector); $eventBus-\u0026gt;subscribe(CourseCapacityChangedEvent::class, $courseListProjector); $eventBus-\u0026gt;subscribe(StudentSubscribedToCourseEvent::class, $courseListProjector); $eventBus-\u0026gt;subscribe(StudentUnsubscribedFromCourseEvent::class, $courseListProjector); $eventBus-\u0026gt;subscribe(StudentRegisteredEvent::class, $courseListProjector); $eventBus-\u0026gt;subscribe(CourseDefinedEvent::class, $studentListProjector); $eventBus-\u0026gt;subscribe(StudentRegisteredEvent::class, $studentListProjector); $eventBus-\u0026gt;subscribe(StudentSubscribedToCourseEvent::class, $studentListProjector); $eventBus-\u0026gt;subscribe(StudentUnsubscribedFromCourseEvent::class, $studentListProjector); // Step 1: Purge existing projections $projectionStore-\u0026gt;purge(); $projectionStore-\u0026gt;commit(); echo \u0026#34;Purged existing projections\\n\u0026#34;; // Step 2: Replay all events $inspector = new Inspector($eventBus); $eventStore-\u0026gt;inspect($inspector); echo \u0026#34;Replayed all events\\n\u0026#34;; // Step 3: Commit rebuilt projections $projectionStore-\u0026gt;commit(); echo \u0026#34;Rebuild complete\\n\u0026#34;; This serial approach is effective for getting started but processes events sequentially in a single PHP process.\nDisabling stream enrichment# If your application uses a stream enricher, disable it during rebuilds to prevent metadata enrichment. Stream enrichers typically add contextual information like user IDs, tenant identifiers, or correlation IDs to events as they occur.\nDuring rebuilds, you\u0026rsquo;re replaying historical events that already contain their original metadata. Re-enriching them would:\nAdd incorrect contextual data from the rebuild process rather than the original context Potentially modify event metadata in unintended ways Cause unnecessary processing overhead Disable enrichment by not registering the enricher middleware when bootstrapping your rebuild script:\n1 2 3 4 5 6 // Normal application bootstrap registers enricher middleware $eventStore-\u0026gt;addMiddleware(new StreamEnricherEventStoreMiddleware($enricher)); $eventBus-\u0026gt;addMiddleware(new StreamEnricherEventBusMiddleware($enricher)); // Rebuild script omits enricher middleware entirely // Just use EventStore and EventBus without enricher middleware Alternatively, implement methods like enable() and disable() on your stream enricher to toggle activation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class StreamEnricher implements StreamEnricherInterface { private bool $enabled = true; public function enable(): void { $this-\u0026gt;enabled = true; } public function disable(): void { $this-\u0026gt;enabled = false; } public function enrich(EventStreamInterface $stream): EventStreamInterface { if (!$this-\u0026gt;enabled) { return $stream; } // Enrichment logic here } } // In rebuild script $enricher-\u0026gt;disable(); // After rebuild $enricher-\u0026gt;enable(); This approach allows you to keep the enricher middleware registered while controlling when enrichment occurs.\nImplementing parallel rebuilds# For large event stores, parallel rebuilding improves performance by running each projector in a separate PHP process. This approach reduces memory consumption and CPU usage by distributing work across multiple workers.\nOne suggested parallel rebuild strategy involves two scripts:\nMain coordinator script that:\nDeletes all existing projections Loops through all projectors Launches a background process for each projector, passing the projector class name as an argument Waits for all background processes to complete Worker script that:\nReceives the projector class name as an argument Determines which events the projector is interested in Creates a query filtering for those specific events using EventClass::in() Uses the Inspector with this query to replay only the relevant events Creates a dedicated EventBus and registers only that projector Instructs the EventStore to inspect using the filtered Inspector Commits the rebuilt projections for that projector only This approach allows each projector to process only its relevant events independently, enabling true parallel execution where multiple projectors rebuild simultaneously in separate PHP processes.\nEach worker performs its own commit(), ensuring that projections are persisted independently.\nImportant: This parallel method requires projectors to be fully autonomous. Projectors must not depend on projections built by other projectors, as those projections may not be available when needed during concurrent execution. Each projector should derive all necessary information solely from events. When projectors are autonomous, there is no risk of conflicts between workers since each projector manages distinct projections.\nFiltering events for parallel rebuilds# When implementing the worker script, use the Inspector with a query to replay only events relevant to the specific projector. Adding a static method to each projector that returns its subscribed events simplifies worker scripts and centralizes event subscription knowledge:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class CourseListProjector implements EventHandlerInterface { use EventHandlerTrait; public static function getSubscribedEvents(): array { return [ CourseDefinedEvent::class, CourseCapacityChangedEvent::class, StudentSubscribedToCourseEvent::class, StudentUnsubscribedFromCourseEvent::class, ]; } // Handler methods... } The worker script can then call this method to determine which events to load:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 use Backslash\\EventStore\\Query\\EventClass; use Backslash\\StreamPublishingInspection\\Inspector; // Worker receives projector class name as argument $projectorClass = $argv[1]; // e.g., CourseListProjector::class // Get subscribed events from projector $eventClasses = $projectorClass::getSubscribedEvents(); // Create query to filter for relevant events only $query = EventClass::in($eventClasses); // Create and register projector $eventBus = new EventBus(); $projector = new $projectorClass($projectionStore); foreach ($eventClasses as $eventClass) { $eventBus-\u0026gt;subscribe($eventClass, $projector); } // Create Inspector with the filtering query $inspector = new Inspector($eventBus, $query); // Replay only the filtered events $eventStore-\u0026gt;inspect($inspector); // Commit the rebuilt projections $projectionStore-\u0026gt;commit(); This pattern ensures each worker processes only its necessary events, avoiding unnecessary event handling and improving rebuild performance. The Inspector with the query guarantees that only relevant events are replayed through the EventBus.\nBest practices# Make the application unavailable during rebuilds. The application should not be accessible while rebuilding projections to prevent inconsistent reads and potential data corruption. For live rebuilds without downtime, rebuild projections in separate storage and ensure new events created during the rebuild are processed after completion; this requires careful orchestration and is beyond the scope of basic rebuilds.\nSeparate projectors from processors. Maintain clear boundaries between event handlers that update projections and those that trigger side effects; this separation is essential for safe rebuilds.\nTest rebuild logic before production. Verify your rebuild implementation works correctly on a copy of production data before executing against live projections.\nSchedule rebuilds during maintenance windows. Rebuilding can be resource-intensive for large event stores; schedule rebuilds during low-traffic periods to minimize impact.\nMonitor rebuild progress. For large event stores, add logging to track rebuild progress and identify potential issues early; consider logging after every N events processed.\nUse selective rebuilds when possible. Rebuild only affected projections rather than all projections to save time and resources; create temporary EventBus instances with only the necessary projectors.\nConsider parallel rebuilds for scale. As your event store grows, parallel rebuilds become increasingly valuable for reducing rebuild time and resource consumption.\nBackup before rebuilding. Consider backing up projection data before rebuilding in case you need to roll back; this is especially important for production systems.\nKeep projectors idempotent. Design projectors to produce the same result regardless of how many times events are replayed; this ensures reliable rebuilding and recovery.\nDocument your rebuild process. Maintain clear documentation of your rebuild procedures, including when to rebuild, how to execute rebuilds, and expected duration for different projection sets.\n"}]